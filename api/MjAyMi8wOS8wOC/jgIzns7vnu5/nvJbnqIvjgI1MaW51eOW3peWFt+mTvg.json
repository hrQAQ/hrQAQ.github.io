{"title":"「系统编程」Linux工具链","date":"2022-09-08T14:37:41.000Z","date_formatted":{"ll":"Sep 8, 2022","L":"09/08/2022","MM-DD":"09-08"},"thumbnail":"https://oss.horik.cn/blog/header-linux-tools.jpg","link":"2022/09/08/「系统编程」Linux工具链","comments":true,"tags":["Linux基础","Makefile","gcc","gdb"],"categories":["系统编程"],"updated":"2022-10-01T15:59:32.000Z","content":"<p>GNU 工程开发了大量用于 Unix 的自由软件工具，其中<strong>GNU工具链</strong>（英语：GNU toolchain）是一个包含了由GNU计划所产生的各种编程工具的集合，由自由软体基金会负责维护工作。这些工具形成了一条工具链，用于开发应用程序和操作系统。</p>\n<p><img src=\"https://www.gnu.org/graphics/heckert_gnu.transp.small.png\" alt=\" [GNU头像] \" loading=\"lazy\" class=\"φbp\"></p>\n<blockquote>\n<p>Hint 1</p>\n<p>自由软件意味着使用者有运行、复制、发布、研究、修改和改进该软件的自由。</p>\n</blockquote>\n<blockquote>\n<p>Hint 2</p>\n<p>“GNU”这个名字是“GNU’s Not Unix”的递归首字母缩写词。“GNU”的发音为<em>g’noo</em>，只有一个音节，发音很像“grew”，但需要把其中的<em>r</em>音替换为<em>n</em>音。</p>\n</blockquote>\n<p>这篇文章是对GNU工具链中的编译套件（gcc），调试工具（gdb），构建和管理工具（make）的常用功能陈列。其实网上已经有很多这种总结帖子了，按照不重复造轮子的原则，我其实不应该花时间来做这个总结的。但我这刚开博客坑没几天，好歹得有点产出吧（笑，写写这种东西也不费事儿，纯当写memo备忘了。另外，如果你想上手工具的话，最好的办法是先有个大概了解，心里有谱了就可以上手用了，需要用什么再查什么。事实上，读or写这种文档就像是学英语背牛津词典一样，味同嚼蜡（这是最后一篇重复造轮子的文章 &gt;_&lt; ）</p>\n<h2 id=\"gcc---基于c/c++的compiler\">GCC - 基于C/C++的Compiler<a title=\"#gcc---基于c/c++的compiler\" href=\"#gcc---基于c/c++的compiler\"></a></h2>\n<p>gcc的全称是GNU Compiler Collection,即GNU编译器套件.它的初衷是为了给GNU操作系统专门写一款编译器,以解决不同GNU系统间编译器混乱的问题，现在,它已经可以编译众多语言,例如C, C++, Objective-C, Fortran, Ada, Go.并且成为了C, C++编译器的首选。</p>\n<p>gcc是编译器套件，它提供了编译的全过程工具。</p>\n<p><img src=\"https://self-image-storage.oss-cn-beijing.aliyuncs.com/PicGo/%E7%BC%96%E8%AF%91%E5%85%A8%E8%BF%87%E7%A8%8B.png\" alt=\"image-20220908161511330\" loading=\"lazy\" class=\"φbp\"></p>\n<h3 id=\"编译的四个阶段\">编译的四个阶段<a title=\"#编译的四个阶段\" href=\"#编译的四个阶段\"></a></h3>\n<p>如上图所示，广义上的C语言编译过程分为4个阶段，gcc编译器套件也对应为了四个部件：</p>\n<ul>\n<li>\n<p>预处理器 cpp</p>\n<p>主要完成三项工作：将原文件中的头文件展开，宏替换，去注释</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">~$&gt; gcc -E hello.c hello.i<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>编译器 gcc</p>\n<p>将C语言代码翻译为汇编语言代码</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">~$&gt; gcc -S hello.i hello.s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>汇编器 as</p>\n<p>将汇编语言代码翻译为二进制的可重定位文件</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">~$&gt; gcc -c hello.s -o hello.o<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>链接器 ld</p>\n<p>将函数库中的代码组合到目标文件中</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">~$&gt; gcc hello.o -o a<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"gcc常用参数\">gcc常用参数<a title=\"#gcc常用参数\" href=\"#gcc常用参数\"></a></h3>\n<p>有了以上四个阶段的认识以后，我们再来介绍gcc的常用参数</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">-o：指定生成的输出文件名字；\n-E：仅执行编译预处理；\n-S：将C代码转换为汇编代码；\n-wall：显示警告信息；\n-c：仅执行编译操作，不进行连接操作。\n-I：给出头文件的目录路径\n-g: 保留调试需要使用的信息，需要gdb调试的时候使用此选项\n-O: 编译的优化等级，未指定时默认不优化，O0\\O1\\O2\\O3优化效果逐步递增\n-D name: 编译时宏定义。在编译时预定义名称为name的宏，源代码中的name被替换为1\n-l：用来指定程序要链接的库，-l参数紧接着就是库名\n-L: dir选项。该选项将dir添加到库文件搜索路径中\n-static: 该选项表示在编译时强制使用对应的静态链接库\n-shared: 该选项创建共享库。它所创建的动态库文件以.so后缀结尾。\n-ansi: 等价于-std&#x3D;c89。该选项指定源程序使用ISO C90标准\n-std&#x3D;: 它确定源程序中所使用的C语言标准<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>给出一些实例，如果你都能看明白就会用gcc了，如果存有疑问，请查看<a href=\"https://wangchujiang.com/linux-command/c/gcc.html\" target=\"_blank\">https://wangchujiang.com/linux-command/c/gcc.html</a></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 无选项编译链接\n~$&gt; gcc test.c\n# 选项 -o\n~$&gt; gcc test.c -o test\n# 选项 -E\n~$&gt; gcc -E test.c -o test.i\n# 选项 -S\n~$&gt; gcc -S test.i\n# 选项 -c\n~$&gt; gcc -c test.s\n# 无选项链接\n~$&gt; gcc test.o -o test\n# 选项 -O\n~$&gt; gcc -O1 test.c -o test\n# 选项 -D\n~$&gt; gcc -DDEBUG -o debug debug.c\n~$&gt; gcc -DDEBUG&#x3D;0 -o debug debug.c\n# 选项 -I dir 将 dir 增加至头文件搜索路径\n~$&gt; gcc test.c –I..&#x2F;inc -o test\n~$&gt; gcc hello.c -lpthread -I &#x2F;lib64&#x2F; -o hello\n# 选项 -L dir 将 dir 增加至库文件搜索路径\n# 选项 -I library 指定编译时搜索的库名\n~$&gt; gcc hello.c -L . -lpthread -I &#x2F;lib64&#x2F; -o hello\n\n# 多文件编译--plan A\n~$&gt; gcc testfun.c test.c -o test\n# 多文件编译--plan B\n~$&gt; gcc -c testfun.c    #将testfun.c编译成testfun.o\n~$&gt; gcc -c test.c       #将test.c编译成test.o\n~$&gt; gcc testfun.o test.o -o test    #将testfun.o和test.o链接成test\n\n# 生成静态链接库\n~$&gt;  cd test\n~$&gt;  gcc -c *.c\n~$&gt;  ar rcs libtest.a *.o\n\n# -fPIC PIC 指 Position Independent Code\n# -share 生成一个共享对象，可以与其他对象链接以形成可执行文件。\n# 从源文件生成动态链接库\n~$&gt; gcc -fPIC -shared func.c -o libfunc.so\n# 从目标文件生成动态链接库\n~$&gt; gcc -fPIC -c func.c -o func.o\n~$&gt; gcc -shared func.o -o libfunc.so\n# 加载动态链接库\n~$&gt; gcc hello.c -lpthread -o hello<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"gdb---功能强大的debugger\">GDB - 功能强大的Debugger<a title=\"#gdb---功能强大的debugger\" href=\"#gdb---功能强大的debugger\"></a></h2>\n<h3 id=\"gdb功能介绍\">gdb功能介绍<a title=\"#gdb功能介绍\" href=\"#gdb功能介绍\"></a></h3>\n<p>功能强大的程序调试器，<strong>gdb命令</strong> 包含在GNU的gcc开发套件中，是功能强大的程序调试器。GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。</p>\n<h3 id=\"使用gdb的前置工作\">使用gdb的前置工作<a title=\"#使用gdb的前置工作\" href=\"#使用gdb的前置工作\"></a></h3>\n<p>在使用gdb调试器之前需要完成两项准备工作：</p>\n<ul>\n<li>\n<p>开启程序崩溃信息转储，将崩溃信息存储到core文件内</p>\n<blockquote>\n<p>core文件生成路径:\t默认在输入可执行文件运行<strong>命令</strong>的同一路径下（不是可执行文件的同一路径下）</p>\n</blockquote>\n<p>使用ulimit -c命令查看core文件的生成开关。若结果为0，则表示关闭了此功能，不会生成core文件。相关命令如下：</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ulimit -c # 查看core文件的生成开关\nulimit -c unlimited # 让程序在崩溃时产生core文件\nulimit -c filesize # 限制core文件的大小（filesize的单位为kbyte）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>在开启gdb调试之前，需要在编译源程序的时候加上-g选项</p>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gcc -g test.c func.c -o test.out<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n</ul>\n<p>在完成以上两项准备工作后，我们就可以使用gdb来对程序调试了</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">gdb test.out test.out-core # 进行调试<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"gdb常用命令\">gdb常用命令<a title=\"#gdb常用命令\" href=\"#gdb常用命令\"></a></h3>\n<p>这一部分的实例介绍直接看manual： <a href=\"https://wangchujiang.com/linux-command/c/gdb.html%EF%BC%8C%E4%B8%8B%E9%9D%A2%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9Bmanual%E4%B8%8A%E9%9D%A2%E6%B2%A1%E6%9C%89%E7%9A%84and%E5%86%99%E7%9A%84%E4%B8%8D%E6%98%AF%E7%89%B9%E5%88%AB%E8%AF%A6%E7%BB%86%E7%9A%84%EF%BC%9A\" target=\"_blank\">https://wangchujiang.com/linux-command/c/gdb.html，下面补充一些manual上面没有的and写的不是特别详细的：</a></p>\n<p><strong>gdb日志</strong></p>\n<p>如果你想把GDB调试过程中的屏幕显示内容保存为日志，有以下的命令与此相关（如果你看不懂下面的命令，或许可以在这里找到一点帮助：<a href=\"https://blog.horik.cn/2022/09/04/%E3%80%8C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E3%80%8D%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4#the-missing-semester-of-computer-science------linux-%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80\" target=\"_blank\">The Missing Semester of Computer Science ---- Linux 命令基础</a>）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(gdb) set logging on\n(gdb) set logging off\n(gdb) set logging file &lt;filename&gt;\n(gdb) set logging overwrite [on|off] &#x2F;&#x2F;默认会追加到logfile里 \n(gdb) set logging redirect [on|off] &#x2F;&#x2F;默认GDB输出会在terminal和logfile里显示，用redirect让它只在logfile里显示\n(gdb) show logging<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>快照信息 checkpoint</strong></p>\n<p>gdb可以在程序执行的过程中保留快照(状态)信息，称之为checkpoint，可以在进来返回到该处再次查看当时的信息，比如内存、寄存器以及部分系统状态。通过设置checkpoint，万一调试的过程中错误发生了但是已经跳过了错误发生的地方，就可以快速返回checkpoint再开始调试，而不用重启程序重新来过。（PS: 类似于游戏存档）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(gdb) checkpoint # 在当前位置设置快照\n(gdb) info checkpoint\t# 查看所有快照点信息\n(gdb) restart checkpoint-id\n(gdb) delete checkpoint checkpoint-id<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>断点 breakpoint</strong></p>\n<p>在一个位置上设置断点，可以对应多个位置，gdb要自动在需要的位置插入断点。在动态库里也可以设置断点，不过其地址在加载后才能解析。 断点的设置有几种方法</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(gdb) break\n(gdb) b\t\t&#x2F;&#x2F;缩写\n(gdb) break [Function Name]\t\t&#x2F;&#x2F;函数名\n(gdb) break [File Name]:[Line Number]\t&#x2F;&#x2F;文件名的第几行 \n(gdb) break [Line Number] \t&#x2F;&#x2F;第几行\n(gdb) break *[Address]\t&#x2F;&#x2F; 想在地址0x4007d9 上设定断点 eg: break *0x4007d9\n(gdb) i line &lt;filename&gt;:&lt;line number&gt;\t&#x2F;&#x2F; 获取对应行在内存中的地址的方法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>条件断点设置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(gdb) break [...] if [Condition]\n(gdb) break [...] thread [Thread-id]\n\neg.\n(gdb) break main if argc &gt; 1\n(gdb) break 180 if (string &#x3D;&#x3D; NULL &amp;&amp; i &lt; 0)\n(gdb) break test.c:34 if (x &amp; y) &#x3D;&#x3D; 1\n(gdb) break myfunc if i % (j+3) !&#x3D; 0\n(gdb) break 44 if strlen(mystring) &#x3D;&#x3D; 0\n(gdb) b 10 if ((int)$gdb_strcmp(a,&quot;chinaunix&quot;) &#x3D;&#x3D; 0)\n(gdb) b 10 if ((int)aa.find(&quot;dd&quot;,0) &#x3D;&#x3D; 0)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>可以用info breakpoints来查看相应断点信息</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">info breakpoints<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><strong>变量打印 print</strong></p>\n<p>print接受表达式和计算它的值。任何该语言支持常值，变量和操作符都可以使用，像条件表达式，函数调用，类型转换，字符常量。GDB还支持数组常量，语法是{element, element…}, 比如print {1,2,3}</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">p[&#x2F;fmt] &lt;变量名称&gt;\n\n# fmt是print变量的格式<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>设置程序中断时的观测变量 display</strong></p>\n<p>设置程序中断后欲显示的数据及其格式。如果你发现你经常要打印某个表达式，你可以把它加入到“automatic display list”。每次程序停止时，都会显示</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">display expr\ndisplay&#x2F;fmt expr\ndisplay&#x2F;fmt addr\nundisplay &lt;dnums&gt;  delete display dnums\ndisable display dnums\nenable display dnums\n\n# 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令\ndisplay &#x2F;i $pc\n# 其中 $pc 代表当前汇编指令，&#x2F;i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>监视变量变化，并且在变化时停止程序 watch</strong></p>\n<p>监视点是监视特定内存位置、特定表达式的值是否改变而触发程序暂停执行，而不用去关心该值到底在代码的哪个位置被修改的。监视的表达式可以是：某个变量的引用、强制地址解析(比如(int )0x12345678，你无法watch一个地址，因为地址是永远也不会改变的)、合理的表达式(比如a-b+c/d，gdb会检测其中引用的各个变量)。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">watch [-l|-location] expr [thread thread-id] [mask maskvalue]\n\n# -location会让gdb计算expr的表达式，并将计算的结果作为地址，并探测该地址上的值\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>watch命令还存在两个变体：读监视点rwatch当expr被程序读的时候触发中断；读写监视点awatch会在程序读取或者写入expr的时候被中断</p>\n<p><strong>查看调用栈 bt</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(gdb) bt\n#0 level0 () at recursion.cpp:5\n#1 0x08048462 in test (level&#x3D;0) at recursion.cpp:17\n#2 0x0804845b in test (level&#x3D;1) at recursion.cpp:14\n#3 0x0804845b in test (level&#x3D;2) at recursion.cpp:14\n#4 0x0804845b in test (level&#x3D;3) at recursion.cpp:14\n#5 0x0804845b in test (level&#x3D;4) at recursion.cpp:14\n#6 0x0804845b in test (level&#x3D;5) at recursion.cpp:14\n#7 0x08048479 in main () at recursion.cpp:22\n\n(gdb) bt -2\n#6 0x0804845b in test (level&#x3D;5) at recursion.cpp:14\n#7 0x08048479 in main () at recursion.cpp:22<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>帧信息 frame</strong></p>\n<p>frame用来显示当前帧的信息 基本语法是</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">frame\nframe [Frame number]\nf\ninfo|i frame # 相比直接的frame，这个命令输出更详细的stack frame信息<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>查看源代码 list *$pc</strong>*</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">list *$oc\ninfo line<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p><strong>程序信息查看 info</strong></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">info registers | i reg\ninfo &lt;variables&gt; | i &lt;var&gt; # 可以用 i var 来查看某个全局或者静态变量在哪个文件定义的\ninfo locals # 显示当前帧的函数的ju&#39;bu\ninfo args # 显示当前帧的函数的参数， 配合frame，up和down来使用\ninfo func # 显示所有的函数名\ninfo files # 显示所有函数名\ninfo break # 显示断点列表，包括每个断点到达的次数<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>设置变量值 set</strong></p>\n<p>gdb可修改运行时的参数，并使该变量按照用户当前输入的值继续运行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 在单步执行的过程中，键入命令：\nset 变量＝设定值<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<hr>\n<h2 id=\"make---gnu的工程化编译工具\">Make - GNU的工程化编译工具<a title=\"#make---gnu的工程化编译工具\" href=\"#make---gnu的工程化编译工具\"></a></h2>\n<blockquote>\n<p>无论是在linux 还是在Unix环境 中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或make install。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以简洁明快地理顺各个源文件之间纷繁复杂的相互关系。</p>\n<p>而且如此多的源文件，如果每次都要键入gcc命令进行编译的话，那对程序员 来说简直就是一场灾难。而make工具则可自动完成编译工作，并且可以只对程序员在上次编译后修改过的部分进行编译。</p>\n<p>因此，有效的利用make和 makefile工具可以大大提高项目开发的效率。同时掌握make和makefile之后，您也不会再面对着Linux下的应用软件手足无措了。</p>\n</blockquote>\n<p>make是一个自动化的程序自动维护工具。它根据Makefile所描述的“依赖关系”自动决定项目的那些部分需要重新编译。</p>\n<p>它的维护是基于依赖推导的，也就是说如果某个源程序文件被修改，那么依赖这个源程序文件的所有目标文件，都需要重新编译。如果仅修改了某几个源文件，则只重新编译这几个源文件，如果某个头文件被修改了，则重新编译所有包含该头文件的源文件</p>\n<h3 id=\"make-执行步骤\">make 执行步骤<a title=\"#make-执行步骤\" href=\"#make-执行步骤\"></a></h3>\n<ol>\n<li>\n<p>读入所有的Makefile。</p>\n</li>\n<li>\n<p>读入被include的其它Makefile。</p>\n</li>\n<li>\n<p>初始化文件中的变量。</p>\n</li>\n<li>\n<p>推导隐式规则，并分析所有规则。</p>\n</li>\n<li>\n<p>为所有的目标文件创建依赖关系链。</p>\n</li>\n<li>\n<p>根据依赖关系，决定哪些目标要重新生成。</p>\n</li>\n<li>\n<p>执行生成命令</p>\n</li>\n</ol>\n<h3 id=\"makefile-书写规则\">makefile 书写规则<a title=\"#makefile-书写规则\" href=\"#makefile-书写规则\"></a></h3>\n<p>阅读以下示例即可</p>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\"># main是target，即make最终需要创建的文件，如可执行文件和目标文件；\n# main.o hello1.o hello2.o 是这个target的dependency 通常是编译目标文件所需要的其他文件\nmain:main.o hello1.o hello2.o\n\t# 下面是生成main的command，是make执行的动作，通常是把指定的相关文件编译成目标文件的编译命令，每个命令占一行，且每个命令行起始字符必须为TAB字符\n\tgcc -o main main.o hello1.o hello2.o \n\t\nmain.o:main.c hello1.h hello 2.h \n\tgcc -c main.c\n\nhello1.o: hello 1.c hello 1.h \n\tgcc -c hello1.c \n\nhello2.o: hello2.c hello2.h \n\tgcc -c hello2.c\n\n# clean是target target也可以是要执行的动作，如clean\nclean:\n\trm main hello1.o hello2.o main.o<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>执行上面这个makefile</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">make | make main\t# 生成main\nmake target \t# 选择目标\nmake clean\t# 执行清理<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\"># 伪目标\nall: prog1 prog2 prog3\n\nprog1: prog1.o utils.o\n\tgcc -o prog1 prog1.o utils.o\n\t\nprog2: prog2.o\n\tgcc -o prog2 prog2.o\n\t\nprog3: prog3.o sort.o utils.o\n\tgcc -o prog3 prog3.o sort.o utils.o\n\t\n# 声明clean是伪目标，防止有clean文件存在使得makefile认为此命令无需执行而使得make clean失效\n# 原因：根据依赖关系发现clean命令依赖的内容未发生变化\n.PHONY: clean\nclean:\n        rm *.o temp<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\"># 隐式规则\n# 根据后缀为.c的源文件使用gcc命令自动更新或者产生同名的.o文件，规则中略去产生目标文件的命令。\n# 同时，目标所依赖的文件列表中的.c文件亦可省略\nhello2.o: hello2.h\n\n# 与上面的简化版等价\nhello2.o: hello2.c hello2.h \n\tgcc -c hello2.c<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"makefile-自定义变量\">makefile 自定义变量<a title=\"#makefile-自定义变量\" href=\"#makefile-自定义变量\"></a></h3>\n<p>makefile中的变量主要是为了简化文件，减少重复内容的书写，提高文件可读性。变量的机理是类似宏展开的方式。我们一般使用变量完成以下工作：</p>\n<ul>\n<li>存储文件名列表</li>\n<li>存储可执行文件名</li>\n<li>存储编译器标识</li>\n<li>存储参数列表</li>\n</ul>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\"># \\ 代表本行内容尚未结束，下一行继续写，用于缩短行的长度，增加程序可读性\n# objeckts变量存储了文件名列表，减少了重复\nobjects &#x3D; main.o kbd.o command.o display.o \\ \n\tinsert.osearch.o files.o utils.o\n\nedit : $(objects)\n \tcc -o edit $(objects)\n \nmain.o : main.c defs.h\n\tcc -c main.c\n\nkbd.o : kbd.c defs.h command.h\n\tcc -c kbd.c\n\n...\n\nclean :\n\trm edit $(objects)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\">obj&#x3D; main.o hello1.o hello2.o\n\nmain: $(obj)\n\tgcc -o main $(obj)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"makefile-内部变量\">makefile 内部变量<a title=\"#makefile-内部变量\" href=\"#makefile-内部变量\"></a></h3>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\"># 当前规则的目标文件名\n$@\n\n# 成依赖列表中第一个依赖文件\n$&lt; \n\n# 比目标文件更新的以空格分隔的整个依赖的列表\n$?\n\n# 以空格分隔的所有的依赖文件\n$^：\n\n# 与$^功能相似，但包含有重复的依赖文件\n$+<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>自动变量简化以后的makefile</p>\n<pre class=\"line-numbers language-makefile\" data-language=\"makefile\"><code class=\"language-makefile\">main:main.o hello1.o hello2.o\n\tgcc -o <svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"1.808ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewbox=\"0 -791.3 778.5 936.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">@ </title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMAIN-40\" d=\"M56 347Q56 429 86 498T164 612T270 680T386 705Q522 705 622 603T722 349Q722 126 608 126Q541 126 513 176Q512 177 512 179T510 182L509 183Q508 183 503 177T487 163T464 146T429 132T385 126Q311 126 251 186T190 347Q190 448 251 508T385 568Q426 568 460 548T509 511T531 479H555Q580 479 582 478Q586 477 587 468Q588 454 588 338V260Q588 200 593 182T619 163Q641 163 655 178T674 223T680 273T682 325V330Q682 426 647 500Q611 569 544 618T388 668Q271 668 184 577T96 347Q96 216 180 121T396 26Q421 26 446 28T493 34T535 43T573 52T605 63T629 72T647 80T657 84H716Q722 78 722 74Q722 65 675 45T547 7T392 -11Q255 -11 156 90T56 347ZM274 347Q274 266 308 214T390 162Q420 162 449 182T498 235L504 245V449L498 459Q453 532 387 532Q347 532 311 483T274 347Z\"/>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMAIN-40\" x=\"0\" y=\"0\"/>\n</g>\n</svg>^\n\nmain.o:main.c hello1.h hello 2.h\n\tgcc -c $&lt; \n\nhello1.o: hello 1.c hello 1.h \n\tgcc -c $&lt; \n\nhello2.o: hello2.c hello2.h \n\tgcc -c $&lt;\n\nclean:\n\trm main hello1.o hello2.o main.o<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","prev":{"title":"「系统编程」动态链接库的创建和使用","link":"2022/09/14/「系统编程」动态链接库的创建和使用"},"next":{"title":"「计算机组成原理」数制基础","link":"2022/09/07/「计算机组成原理」数制基础"},"plink":"http://blog.horik.cn/2022/09/08/「系统编程」Linux工具链/","toc":[{"id":"gcc---基于c/c++的compiler","title":"GCC - 基于C&#x2F;C++的Compiler","index":"1","children":[{"id":"编译的四个阶段","title":"编译的四个阶段","index":"1.1"},{"id":"gcc常用参数","title":"gcc常用参数","index":"1.2"}]},{"id":"gdb---功能强大的debugger","title":"GDB - 功能强大的Debugger","index":"2","children":[{"id":"gdb功能介绍","title":"gdb功能介绍","index":"2.1"},{"id":"使用gdb的前置工作","title":"使用gdb的前置工作","index":"2.2"},{"id":"gdb常用命令","title":"gdb常用命令","index":"2.3"}]},{"id":"make---gnu的工程化编译工具","title":"Make - GNU的工程化编译工具","index":"3","children":[{"id":"make-执行步骤","title":"make 执行步骤","index":"3.1"},{"id":"makefile-书写规则","title":"makefile 书写规则","index":"3.2"},{"id":"makefile-自定义变量","title":"makefile 自定义变量","index":"3.3"},{"id":"makefile-内部变量","title":"makefile 内部变量","index":"3.4"}]}],"reward":true,"copyright":{"author":"Horik","link":"<a href=\"http://blog.horik.cn/2022/09/08/「系统编程」Linux工具链/\" title=\"「系统编程」Linux工具链\">http://blog.horik.cn/2022/09/08/「系统编程」Linux工具链/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"September 8, 2022","updated":"October 1, 2022"},"reading_time":"4372 words in 29 min"}