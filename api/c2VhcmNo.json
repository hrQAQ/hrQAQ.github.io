[{"title":"「编译原理」词法分析基础","date":"2022-11-08T20:10:01.000Z","date_formatted":{"ll":"Nov 8, 2022","L":"11/08/2022","MM-DD":"11-08"},"updated":"2022-11-08T20:10:01.082Z","content":"","plink":"http://blog.horik.cn/2022/11/08/「编译原理」词法分析基础/"},{"title":"「拥塞控制算法」Vivace阅读笔记","date":"2022-11-07T12:09:21.000Z","date_formatted":{"ll":"Nov 7, 2022","L":"11/07/2022","MM-DD":"11-07"},"updated":"2022-11-14T14:25:58.017Z","content":"\nPCC Vivace: Online-Learning Congestion Control\nVivace pronounce as / vɪˈvɑtʃi / not / vɪˈvɑs /\n\nAbstract\n作者在PCC的基础上，借助机器学习中在线学习（凸优化）的概念设计了Vivace。相较于PCC而言，Vivace在两个重要的地方做了改进：\n\n\nrate control protocol【速率控制协议】\na utility function framework【效用方程框架】\n\n\n经过理论证明和实验的验证，Vivace具有以下的优点：\n\n\nVivace significantly outperforms traditional TCP variants, the previous realization of the PCC framework, and BBR in terms of performance (throughput, latency, loss)【性能比TCP variants、PCC、BBR强】\nconvergence speed【收敛速率】\nalleviating bufferbloat【缓解缓冲区膨胀—考虑时延的结果】\nreactivity to changing network conditions【适应高度变化的网络】\nfriendliness towards legacy TCP in a range of scenarios. 【对TCP友好】\nVivace requires only sender-side changes and is thus readily deployable【易于部署】\n\n\n1.Introduction\n作者先定义了一个优秀的拥塞控制算法应该具有的特征（这个定义应该是方便凸显自己的算法的优势的）：\n\n\n\nFirst and foremost, a congestion control architecture should be able to efficiently utilize network resources under varying and complex network conditions. This includes optimizing for throughput, loss, and latency, and doing so in a plethora of environments — potentially with non-congestion loss [8], high-RTT cross-continent links, highly dynamic networks such as WiFi and LTE links, etc.【性能要强】\n\n\nSecond, congestion control should guarantee quick convergence to stable and fair rates when multiple senders compete over network resources.【收敛性（快、稳定）和公平性要好，而且要在多个sender的情况下】\n\n\nLast, a congestion control scheme should be easy and safe (e.g., sufficiently friendly to existing protocols) to deploy【兼容旧体系】\n\n\n\n在占据了定义的制高点后，作者开始批判传统算法，例如CUBIC、Illinois、Vegas：\n\nTraditional algorithms [6, 15, 23] fail to satisfy the first two requirements; their performance can be as high as 10× away from the optimal under non-congestion packet loss [11]【传统算法性能只能达到最优性能的不到十分之一】\n\n批判完传统算法之后，又把炮口朝向了最近的新算法，例如Remy、BBR、PCC：\n\n\nRemy-generated TCPs are inherently prone to degraded performance when the actual network conditions deviate from input assumptions.【Remy还残留了TCP的硬连接方案】\nBBR and PCC Both fail to achieve optimal low latency and exhibit far-from ideal tradeoffs between convergence speed and stability.【BBR和PCC都没有一个好的收敛性】\nBBR exhibits high rate variance and high packet loss rate upon convergence.【BBR稳定性差、收敛时丢包多】\nPCC convergence time is overly long【PCC收敛时间长】\nBBR’s model of the network does not reflect the complexities of reality, performance can suffer severely.【 BBR白盒建模难以全面考虑真实的复杂网络 】\nBBR and PCC are both highly aggressive towards TCP【BBR和PCC都对TCP不友好】\n\n\n终于，作者把能拥塞算法界的所有算法都狠狠批判了一遍以后，提出了自己的解决方案（I solved this problem），并且给出了自己在这个方案上的主要工作内容（也是本文主要介绍的内容）。\n首先我们需要明确，Vivace是PCC的改进版本。正如摘要中所述，Vivace改进了PCC两个部件：①a utility function framework，② a learning rate control algorithm\n\nVivace adopts the high-level architecture of PCC – a utility function framework and a learning ratecontrol algorithm – but realizes both components differently.\n\n在第一个部件，即效用方程上，Vivace的贡献在于引进了learning-theory-informed framework【所以这个到底是啥啊啊啊啊】来做utility的计算（PCC在效用函数的选择上显得很随意），并且这一次Vivace考虑了时延最小化和TCP友好性（PCC没有证明考虑时延时的收敛性，PCC没有做到TCP友好性）【我考虑了时延就等于考虑了TCP友好性】。\n在第二个部件，即速率控制算法上，Vivace使用了基于梯度上升（一种可证明的渐进式在线学习优化）的速率控制算法，达到了：\n\n\nhigh utilization of network capacity\nswift reaction to changes\nfast and stable convergence\n\n\n2.Rate-Control Through Online Learning\n因为PCC在异构的效用方程下的结果并不尽如人意，作者从博弈论的无悔算法获得了灵感。无悔算法保证：\n\nIn addition, results in game theory establish that online learning algorithms “play well” together, in the sense that, under the appropriate conditions, global convergence to a stable equilibrium is guaranteed when there are multiple decision makers.\n\n同时，在线学习能在不确定的条件下做出最大化正确性决定：\n\nOnline learning provides a useful and powerful abstraction for decision making under uncertainty.\n\n\n关于在线学习的背景知识：\n在线学习(Online Learning) - 别来无恙的文章 - 知乎 https://zhuanlan.zhihu.com/p/403393226\n在线学习（Online Learning）导读 - 吴海波的文章 - 知乎 https://zhuanlan.zhihu.com/p/36410780\n\n所以作者把rate control的任务抽象为了一个在线学习的任务，这一个insight 在PCC已经出现过了：\n\nA traffic sender repeatedly selects between sending rates. After sending at a certain rate for “sufficiently long”, the sender learns its performance implications by translating aggregated statistics (e.g., achieved goodput, packet loss rate, average latency) into a numerical utility value, and then adapts the sending rate in response.\n\n在15年的PCC模型中，虽然使用了在线学习的理念，但仍然没有挖掘出在线学习的全部潜力：\n\nFirst, Allegro uses a somewhat arbitrary choice of utility function\n\nfair convergence is not provably guaranteed when utility functions are latency-aware【考虑时延的效用方程未被证明是公平收敛的】\nreasoning about fundamental tradeoffs in parameter settings is difficult【推理参数的调整是很难的，不成体系】\nthere is no theoretical understanding of what happens when Allegro senders with different utility functions interact with each other【异构发送者的互动？】\n\n\nSecond, Allegro inherently ignores the information reflected in the utility when deciding on step size\n\nε是固定的，大了难以收敛，小了收敛太慢\n没有充分利用utility 反应的信息\n\n\n\n为了解决15年PCC模型的问题，Vivace使用了在线学习+凸优化的思想，重新实现PCC高层架构的两个关键部分：（1）效用函数框架，以及（2）学习速率控制算法，达到了一个比较好的效果：\n\n\n\nFirst, Vivace relies on a new, learning-theory-informed framework for utility derivation [12], which guarantees multiple competing Vivace senders will converge to a unique stable rate configuration that is fair and near-optimal.【保证多个异构决策者会收敛到一个公平点】\n\n\nSecond, Vivace employs provably optimal gradient-ascent-based no-regret online optimization [37] to adjust sending rates, taking into account not only the direction (increase/decrease) that is more beneficial utility-wise, but also the extent to which increasing/decreasing the rate impacts utility.【基于梯度上升+无悔在线优化调整发送速率，保证收敛速度】\n\n\n\n之前一直提到无悔学习，或者说无遗憾学习（no-regret learning）,之前学经管的时候做过一点最小后悔值的计算，但对于无悔学习的收敛性没有认识，这里我补充了一些背景知识（非常粗浅的了解，还有待学习）【（选择更好的u这里体现了无悔？确实如此，后来我了解到梯度下降就是一种no-regret算法】\n\n一般来讲，采用基于后悔值的学习方法以后，每个智能体根据各个行为的后悔值做出行为选择。如果一种算法能够保证最大后悔值渐进的变为零，那么该种算法就可以被称作无悔学习算法。\n最著名的无悔学习算法就是后悔匹配算法(regret matching)，在每一个决策时刻，每个智能体按照每个行为的后悔值的概率做出选择，即具有最大概率的行为被选中的机会越大。在多智能体系统中，如果所有的智能体都采用相同的无悔学习算法，例如后悔匹配算法，那么所有智能体的联合行为将渐进地收敛于一组无悔点。换句话说，一组无悔点也可以被看作一种理想情况或者说一种高效的运行环境。在无悔点集合上，每个智能体所得到的平均回报不少于其它行为所能产生的回报。\n\n作者在文章中分析了无悔学习的优势与劣势（实际上按作者的描述这个劣势对于拥塞控制算法影响并不大）\n\n优势：\n\nno-regret provides a formal performance  guarantee for individual senders across all network conditions【在所有的网络环境下，无悔学习对每个发送者正式地保证了性能】\nno-regret provides a powerful lens for theoretical analysis, which we will use to reason formally about convergence with multiple competing no-regret senders, even with heterogeneous utility functions across the senders, and also about tradeoffs between resilienceto non-congestion loss and loss upon convergence.【无悔学习提供了关于异构的PCC发送者的收敛性理论分析的依据，并且提供了关于稳定性和损失率的平衡的分析方法】\n\n劣势：\n\n动态环境中，无悔算法所逼近的最佳策略是不断变化的，如果逼近的太慢那这个调整就没有意义了。如果遗憾在T个时间单位内消失到一个理想的低值，那么相对于每T个时间单位内的最佳固定策略而言，无遗憾保证就适用。\n\n\n3 Vivace’s Utility Framework\n\n为什么要用梯度呢？\n\nA single sender on a link with a large buffer sends at a rate of twice the capacity of the link for a single MI; then, in the next MI, it tries a slightly lower but still over-capacity rate. Such a sender would experience higher absolute latency in the second MI than in the first MI (since the link’s queue is only further lengthened), even though lowering the rate was clearly the right choice.\nTo learn within a single MI that lowering the rate is more beneficial, the sender examines the rate at which latency increases or decreases.【加入latency的考虑】\n\n3.1 Stability and Fairness\n在给出Vivace采用的效用方程后，Vivace在此基础上展开了稳定性和公平性的分析，作者先引入了博弈论中关于凹函数的理论（如果一个可微函数f它的导数f’在某区间是单调递减的，f就是凹的)\n\nWhen t ≤ 1, the family of utility functions in Equation 1 falls into the category of “socially-concave” in game theory [12].\n\n这里利用了博弈论的理论证明了：一组严格凹函数下的博弈会陷入一组纳什均衡点。再配合上凸优化的梯度上升理论+作者自己搞的信心模块，就保证了收敛的速度也很快。\n\n\n\nguarantees high performance from the individual sender’s perspective\n\n\nensures quick convergence to a global rateconfiguration\n\n\n\n作者预设了一个场景：N个发送者竞争一个具有瓶颈的链路\n\nTheorem 1. When n Vivace-senders share a bottleneck link, and each Vivace-sender i’s utility function is defined as in Eq. 1, the senders’ sending rates converge to a fixed configuration (x∗1, . . . ,x∗ n) such that x∗ 1 = x∗ 2 = . . . = x∗n\nTheorem 2. Let C denote the capacity of the bottleneck link. If b ≥ tn^2−t^ C^t−1^, then the latency in the unique stable configuration is the base RTT.\n\n3.2 Random Loss vs. Congestion\n\nIn a system of n Vivace senders, each ploss-resilient, the loss rate L of each sender i in equilibrium (with no random loss) satisfies:\n\n\n推论：When n → ∞, the congestion loss rate on convergence approaches the random loss resilience p!【发送者趋近于n时损失率趋近设定的忍受率】\n推论：withstanding more random loss comes at the cost of suffering more loss upon convergence for a large number of senders.【随机损失的忍受是以收敛时的损失率为代价的】\n\n3.3 Heterogeneous Senders\nVivace可以通过修改异构发送者的效用方程达到控制链路占用量的效果，这对于未来的SDN是有好处的。\n\nVivace’s utility function framework, in contrast, provides flexibility in resource-allocation. 【ci调整了对损失率的惩罚值】\n\n\n不过我猜异构发送者不支持时延based，不然就不会只写一个loss-based的了。\n\nHence, one can flexibly adjust the bandwidth allocated to each sender at equilibrium by tuning Vivace’s param-\neters {ci}\n\nc_{i}\n\n\n\n\n\n \n \n\n参数的设置方法：\n\n\n4 Vivace’s Rate Control\n最开始慢启动，然后在效用第一次减小后进入速率控制阶段（不再退出）\n4.1 Key Idea and Challenges\n\nwhen the utility functions are strictly convex, which is satisfied when t &lt; 1 in our utility function formulation\n\n作者指出：满足上面条件的效用方程可以保证两件事情：（本文老生常谈的话题了）\n\n\nEach sender is guaranteed that employing Vivace is (asymptotically) no worse than the optimal fixed sending rate\nin hindsight【即使在极度变化的环境也适用】\nWhen multiple senders share the same link, quick convergence to an equilibrium point is guaranteed\n\n\n所以具体怎么控制呢，其实就是把原本PCC的步长修改了一下。以前的步长是ε的倍数，收敛效果不好。现在加了点凸优化对步长的调优方案——梯度（这背后的理论是无悔选择）\n4.2 Translating Utility Gradients to Rates\n先测试两个MI的u值，然后计算梯度，最后给梯度乘一个系数\n\n\n\t\n\n当然，光是这样收敛速度还是不太够，作者又加上了PCC的老思路——信心模块。对于同向的增长，我们让他加大力度。对于突然变向的情况，我们把信心模块重置。\n\n\n\n接着，作者提出了一个异常处理的机制——梯度可能会因为偶发因素而变得异常高，所以需要给步长加一个限定值\n\nWhenever Vivace’s computed rate change (∆r) exceeds ωr, the effective rate change is capped at ωr\n\n这个限定值是动态变化的，Δr &gt; wr 那么w就变大，Δr &lt; wr 那么w就变小，如果速率控制的方向变化了w就重置：\n\n\nSpecifically, ω is updated to ω = ω0 +k · δ following k consecutive rate adjustments in which the gradient-based rate-change ∆r exceeded the dynamic change boundary,\nWhenever ∆r ≤r·ω, Vivace recalibrates the value of k in the formula ω=ω0+k·δ to be the smallest value\nfor which ∆r ≤ rω.\nk is reset to 0 when the direction of rate adjustment changes\n\n\n4.3 Contending with Unreliable Statistics【tricks，其实也是引入了硬连接】\nEstimating the RTT gradient via linear regression.\n一言以蔽之：用线性回归求RTT的梯度【上周讲错了x_x】\nLow-pass filtering of RTT gradient.\n使用低通滤波机制忽略小的、短暂的延时抖动【(&gt; 0.01)的抖动才纳入计算】\nDouble checking abnormal measurements.\n这个补丁是对一种奇怪的现象（偶尔，测量结果会导致 &quot;反直觉 &quot;的观察）进行处理——发送速率升高反而延时降低，作者认为这是一个不太可能发生的事情，所以要recheck一次。如果结果显示确实是这样的，那就把doublecheck的Δr 取个平均。\n\n\neven with complex conditions it is highly unlikely that sending faster is the cause of lower loss; more likely, this is due to measurement noise or changing conditions (e.g., another sender reducing its rate).\n\nMI timeout.\n一个MI窗口的信息大概应该在一个RTT返回回来，如果很久都没回来，说明网络出问题了，所以当超过Timeout时间还没有拿到足够的一个MI的RTT信息，Vivace就会把发送速率减半。\n4.4 TCP Friendliness\n作者认为loss-based 的算法是必然会抢占TCP的带宽的，而Latency based的算法又因为TCP系列的算法是lose-based的，对延时不感兴趣，所有当延时上升的时候，latency based的算法主动谦让，TCP系列得寸进尺，延时维持高位，latency based的算法就被TCP系列支配了。\n所有类似PCC Vivace这样混合型的算法可能可以解决这个困境。作者预设了两个场景：\n\n\na Vivace sender is the only sender on a certain link. It tries out two rates that exceed the link’s bandwidth, and the buffer for that link is not yet full.【not full的链，纯Vivace单流】\nthe Vivace sender is sharing a link that is already heavily utilized by many loss-based protocols like TCP CUBIC and the buffer is, consequently, almost always full.【full 链， 多TCP+单Vivace】\n\n\n经过分析，前者把latency纳入了考虑，后者由于latency在此时变化不大，所以退化为了loss-based去和TCP抢带宽了（PCC Allegro）\n但我还是有几点疑虑：\n\nfull链，多Vivace流会怎么样？是否也会退化？退化以后的收敛性如何？\nfull链，多TCP单Vivace中，Vivace作为loss-based抢占能力如何？退化以后的收敛性如何？\n\n5 Implementation and Evaluation\nLatency awareness (100Mbps, 30ms RTT Emulab bottleneck link)\nPCC Vivace很好地解决了缓冲区膨胀的问题，因为他是一个考虑了时延的算法\n\nRapid reaction to network changes (10-100Mbps, 10-100ms RTT，0-1% random loss)\n\n\nCUBIC不能应对random loss，所以维持低位\n\n\nBBR不能快速应对RTT的变化【因为BBR中probeRTT、probeBDP是不同时间进行的？】\n\n\nAllegro不能在瓶颈带宽下降的时候快速减小发送速率——这会导致丢包\n\n\n\nFair equilibrium (100Mbps, 30ms RTT, 75KB buffer)\n肉眼可见，PCC Vivace的收敛性（稳定、速度）更好\n\nTCP Friendliness\n\nBBR占据接近15%的带宽（不管有多少个TCP竞争者）\nPCC Vivace在网络不拥堵（发送者少）的情况下，抢不过TCP，当TCP发送者多起来的时候，PCC Vivace可以抢资源\n\n\nFlexible equilibrium by tuning utility knobs\n通过调整Ci，可以修改PCC Vivace流在带宽中的占比（纯PCC Vivace竞争）\n\n\nLimitation in Extremely Dynamic Networks\nLTE 有待改进的地方：可能是因为在急剧变化的网络下Vivace计算的结果来的不够及时。\n","thumbnail":"2022/11/07/「拥塞控制算法」Vivace阅读笔记/「拥塞控制算法」Vivace阅读笔记/ball.bmp","plink":"http://blog.horik.cn/2022/11/07/「拥塞控制算法」Vivace阅读笔记/"},{"title":"「编译原理」语法分析","date":"2022-11-03T09:59:01.000Z","date_formatted":{"ll":"Nov 3, 2022","L":"11/03/2022","MM-DD":"11-03"},"updated":"2022-11-09T05:02:49.025Z","content":"语法分析的基本功能是根据文法规则，从源程序单词符号串中识别出语法成分，并进行语法检查。换言之语法分析的任务就是识别符号串S是否为某语法成分。\n语法分析有两大类分析方法：\n\n\n自顶向下分析（推导过程）【需要解决左递归问题和回溯问题】\n\n递归子程序法\nLL分析法\n\n\n\n自底向上分析（规约过程）【需要解决句柄的识别问题】\n\n算符优先分析法\nLR分析法\n\n\n\n自顶向下分析\n给定符号串S，若预测是某一语法成分，则可根据该语法成分的文法,设法为S构造一棵语法树， 若成功,则S最终被识别为某一语法成分,即 S属于L(G[Z])，其中G[Z]为某语法成分的文法，若不成功, 则S不属于L(G[Z])。\n自顶向下分析法需要解决两个问题：左递归、回溯\n消除左递归\n直接左递归\n我们有两种方式消除直接的左递归，第一种使用扩充的BNF表达式，第二种是把左递归改写为右递归。\n使用扩充的BNF表达式\n使用以下两条规则可以完成改写文法的任务\n\n\n左递归改写为右递归\n\n\n间接左递归\n\n\n\n\n解决回溯\n什么是回溯?\n\n分析工作要部分地或全部地退回去重做叫回溯，带来了严重的低效率\n\n为什么会存在回溯问题？\n\n文法中，对于某个非终结符号的规则其右部有多个选择，并根据所面临的输入符号不能准确地确定所要的选择时，就可能出现回溯\n\n怎么解决回溯问题，其实我们有两种方式解决回溯问题：\n\n\n第一种是改写文法，使用扩充的BNF表达式让任意两个语法成分的first集合都不相交，最终对文法的要求是: \nFIRST(αi) ∩ FIRST(αj )=\\phi (i\\neq j)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n第二种是在工程实现上使用超前扫描（这会带来一些性能损失，但是比回溯好）\n\n\n构造不相交的First集合\n计算First集合\n\n改写文法使First集不相交\n\n超前扫描（预读）\n当文法不满足避免回溯的条件时，即各选择的首符号相 交时，可以采用超前扫描的方法，即向前侦察各输入符\n号串的第二个、第三个符号来确定要选择的目标。\n这种方法是通过向前多看几个符号来确定所选择的目标，从本质上来讲也有回溯的味道，因此比改写文法的实现更费时，但是假读仅仅是向前侦察情况，不作任何语义处理工作。\n\n递归子程序法\n需要文法是非左递归的。我们对每一个语法成分都写一个分析子程序，自顶向下调用执行。\n\nLL分析法\n\n分析过程\n看个例子就明白了\n\n\n上面这个推导等价于一个最左推导：\n\n分析表的构造\n分析表的性质如下：\n\n根据这个性质，我们很容易知道分析表的构造与First集合、Follow集合的算法有关，First集合的算法已经介绍过了，接下来介绍一下计算Follow集合的算法：\n\n当我们计算出Follow集合后，就可以构造分析表了：\n\n\n例题\n\n\n自底向上分析\n算符优先分析法\nLR分析法\n\n\nFIRST集、FOLLOW集的构造方法\n\n作为写题而言，FIRST集直接肉眼看就行\n\n\n\n","plink":"http://blog.horik.cn/2022/11/03/「编译原理」语法分析/"},{"title":"「编译原理」词法分析进阶","date":"2022-10-25T10:06:55.000Z","date_formatted":{"ll":"Oct 25, 2022","L":"10/25/2022","MM-DD":"10-25"},"updated":"2022-11-08T20:10:40.735Z","content":"\n本章内容一图以蔽之\n\n\n\n正则文法2正则表达式\n代入规则和BNF规则比较直观，消除递归规则使用了正则表达式中的闭包运算，最终达成了把文法的多个产生式改写成单个表达式的目标。\n\n\n正则表达式2正则文法\n前文的逆运算\n\nNFA2DFA\n\n预备知识：\n\n\\varepsilon-closure\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n的计算方式\n\n\nI_{x}\n\n\n\n\n\n \n \n\n的计算方式\n\n\n多值的状态转移函数导致了NFA在计算机工程上很难实现，每次输入新字符时无法判断下一状态是什么（如果硬要写的话可能需要加上一些试探回溯的步骤），所幸已经有证明：任一NFA都可以经过确定化的步骤后转化为DFA。下文介绍一种NFA的确定化算法。\n先说一些个人理解。NFA不确定性的来源就是\n\\varepsilon\n\n\n\n\n \n\n边和多值边，我们要想把NFA转化为DFA就必须以某种方式把这些边剪除掉。如何剪除这些边呢？我们使用一种类似聚合的办法，把 \n\\varepsilon \n\n\n\n\n \n\n 边所连接的状态聚合为一种状态，把多值边的目标状态聚合为一种状态。经过这样的变换，\n\\varepsilon\n\n\n\n\n \n\n 边和多值边就变成了“状态内的边”了，因此在重新定义的状态上确立的状态机就是DFA。对应到算法中：计算 \n\\varepsilon-closure\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n 闭包的过程完成了聚合 \n\\varepsilon\n\n\n\n\n \n\n 边的任务，计算 \nI_{x}\n\n\n\n\n\n \n \n\n 的过程完成了聚合多值边的任务。\n下面介绍构造DFA的算法步骤：\n\n初始化DFA的状态集合 S ，输入字母表\n\\sum\n\n\n\n\n \n\n （NFA的字母表去除 \n\\varepsilon\n\n\n\n\n \n\n），状态转移函数集合 \n\\delta\n\n\n\n\n \n\n，初始状态\nS_{0}\n\n\n\n\n\n \n \n\n，终态集合Z，待处理状态队列 Q\n计算NFA初态的 \n\\varepsilon-closure\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n，记为初态 \nS_{0}\n\n\n\n\n\n \n \n\n，加入 状态集合S、待处理状态队列 Q\n从Q中取出一个状态\nS_{t}\n\n\n\n\n\n \n \n\n，遍历输入字母表\n\\sum\n\n\n\n\n \n\n ，设输入字符为x，计算\nS_{t}\n\n\n\n\n\n \n \n\n的\nI_{x}\n\n\n\n\n\n \n \n\n闭包，此时我们构造出了新的状态转移函数\nI_{x}=\\delta(S_{t},x)\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n \n \n\n \n \n \n\n ，将其加入状态转移函数集合 \n\\delta\n\n\n\n\n \n\n。若\nI_{x}\n\n\n\n\n\n \n \n\n不在状态集合中，则记录为状态 \nS_{t}\n\n\n\n\n\n \n \n\n，将其加入状态集合 S、待处理状态队列 Q。\n重复步骤3直到Q为空。\n遍历状态集合S，计算 \nS_{t} \\cap Z' \\neq\\phi\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n \n \n\n (\nZ'\n\n\n\n\n\n \n \n\n为NFA的终态集合)，若该式成立则将\nS_{t}\n\n\n\n\n\n \n \n\n加入终态集合Z\n\nDFA的最小化（化简）\n\n正则表达式2DFA\n证明过程就是把正则表达式的归纳定义走了一遍，通过证明DFA支持正则表达式的初值和迭代算符，进而证明了任何正则表达式都有对应的DFA。下面给出一个转化的算法步骤\n\n正则表达式2正则文法\n画出每个推导式的DFA\n根据证明的方式，聚合多个DFA\n\n\nDFA2正则表达式\n\n","thumbnail":"https://images.unsplash.com/photo-1455849318743-b2233052fcff?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1169&q=80","plink":"http://blog.horik.cn/2022/10/25/「编译原理」词法分析进阶/"},{"title":"「编译原理」数据流分析算法","date":"2022-10-17T14:58:07.000Z","date_formatted":{"ll":"Oct 17, 2022","L":"10/17/2022","MM-DD":"10-17"},"updated":"2022-11-08T19:57:31.294Z","content":"\n基本块划分\n标记跳转语句的两个出口就可以得到基本块的入口语句\n\n\nDAG图\n从中间代码建立DAG图\n建立node表，逐步建立DAG图，维护表内的&lt;变量-节点&gt;对应关系。注意在def之前就被use的变量\nC\n\n\n\n\n \n\n需要引入\nC_0 = C\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n从DAG图导出中间代码\n按照拓扑序得到导出序列，使用导出序列的逆序生成中间代码。\n\n数据流分析\n到达定义分析\n数据流方程\nMATHJAX-SSR-25\n基本块的到达定义分析\n\n计算gen、kill【注意kill包含后续的控制流中的语句】\n初始化in、out\n按照数据流方程算in、out【先算out后算in】\n若第三步有变化，则再迭代一轮，否则结束分析\n\n\n\n\n活跃变量分析\n活跃变量数据流分析\n\n先计算每个基本块的def、use【注意def是在使用前定义的变量】\n初始化in、out为空\n按照数据流方程计算in、out一轮\n前一步如果有更新in、out就再迭代一轮，否则结束分析\n\n\n\n\n冲突图\n变量X在变量Y的定义点是活跃变量，那么变量X,Y是冲突变量，这意味着它们在寄存器分配时不能同时使用同一个寄存器。\ndef-use链\n变量的定义-使用链，是指变量的某一定义点，以及所有可能使用该定义点所定义变量值的使用点所组成的一个链 。同一变量的多个定义-使用链，如果它们拥有某个同样的使用点，则合并为同一个网。\n具体计算需要先使用到达定义数据流分析得出。\n\n\nSSA\n算法概览\n\n建立CFG流图\n通过CFG构造Dominator-tree （算法参考）\n在Dominator-tree上计算每个节点的Dominator Frontier（算法参考）\n使用Dominator Frontier插入ϕ指令（支配边界获取了需要Φ函数的精确的位置：如果点A定义了一个变量，那个这个变量将会达到所有点A的支配点，只有在当我们离开这些点，而且进入支配边界，我们才必须考虑其他流程会带着其它相同变量的定义）\n最后重命名变量。\n\n","thumbnail":"https://images.unsplash.com/photo-1484100356142-db6ab6244067?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1067&q=80","plink":"http://blog.horik.cn/2022/10/17/「编译原理」数据流分析算法/"},{"title":"「系统编程」文件操作","date":"2022-10-04T20:10:06.000Z","date_formatted":{"ll":"Oct 4, 2022","L":"10/04/2022","MM-DD":"10-04"},"updated":"2022-10-05T22:14:40.976Z","content":"\n又在写完后才找到API文档…\n本文涉及的 api 可以参考 Linux C API参考手册\n\n\n文件的类型\nLinux七种文件类型详解\n\n\n文件属性\n文件类型\n\n\n\n\n-\n常规文件，即 file\n\n\nd\n目录文件\n\n\nb\nblock device 即块设备文件，如硬盘;支持以 block 为单位进行随机访问\n\n\nc\ncharacter device 即字符设备文件，如键盘支持以 character 为单位进行线性访问\n\n\nl\nsymbolic link 即符号链接文件，又称软链接文件\n\n\np\npipe 即命名管道文件\n\n\ns\nsocket 即套接字文件，用于实现两个进程进行通信\n\n\n文件的权限\numask指定了在建立文件时预设的权限掩码。\numask\n&gt;&gt; 0022\n\numask -S\n&gt;&gt; u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx\n文件读写操作Syscall\n一个比较详细的介绍在这里，本文只记录API\n\n\n打开 open\n#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para pathname：要创建的文件名（包括路径信息）\n* @para\tflags：打开的模式\n* @return 成功返回文件描述符 否则返回-1\n*&#x2F;\nint open(const char* pathname, int flags, ...);\n\n\nMode\nDescription\n\n\n\n\nO_RDONLY\n只读\n\n\nO_WRONLY\n只写\n\n\nO_RDWR\n读写\n\n\nO_NONBLOCK\n非阻塞I/O，如果read(2)调用没有可读取的数据，或者如果write(2)操作将阻塞，则read或write调用将返回-1和EAGAIN错误\n\n\nO_APPEND\n每次写的数据都添加到文件尾\n\n\nO_TRUNC\n若此文件存在，并以读写或只写打开，则文件长度为0\n\n\nO_CREAT\n若文件不存在，则创建该文件。此时，open 函数需要第三个参数，用于指定该文件的访问权限位\n\n\nO_EXCL\n若同时指定了O_CREAT标志，而文件已经存在，则会出错。可用于测试文件是否存在\n\n\nO_DIRECT\n最小化或去掉reading和writing的缓存影响。系统将企图避免缓存你的读或写的数 据。如果不能够避免缓存，那么它将最小化已经被缓存了的数据造成的影响。如果这个标志用的不够好，将大大的降低性能\n\n\nO_ASYNC\n当I/O可用的时候，允许SIGIO信号发送到进程组，例如：当有数据可以读的时候\n\n\n\n\n创建 creat\n注意：当文件存在时，调用creat函数，会将文件的大小变为0\n  #include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para pathname：要创建的文件名（包括路径信息）\n* @para\tmode：同open的第三个参数，讨论文件的访问权限位\n* @return 成功返回只写打开的文件描述符\n*\t\t  出错返回-1\n*&#x2F;\nint creat(const char *pathname, mode_t mode);\n替换creat的方式\n  int open(pathname, O_RDWR | O_CREAT | O_TRUNC,mode);\n\n\n定位 lseek\n  #include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para filedes: open&#x2F;creat函数返回的文件描述符\n* @para offset: 相对偏移量,需结合whence才能计算出真正的偏移量\n* @para: Whence: 从何处开始计算偏移量\n*\t\t\t   \t SEEK_SET \t文件开始处\\\n* \t\t\t\t SEEK_CUR \t文件当前偏移量\\\n*\t\t\t\t SEEK_END\t文件尾部\\\n* @return: 类型off_t：通常情况下是32位数据类型 \\\n*\t\t\t若成功，返回新的文件偏移量 \n*\t\t\t若出错，返回-1\n*&#x2F;\noff_t lseek(int filedes, off_t offset, int whence)\n\n\n读 read\n  #include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para fd: 文件描述符\n* @para buff: 指向缓冲区，用于存放从文件读出的数据\n* @para nbytes: 需要从文件中读出的字节数\n* @constraint: 缓冲区的大小&gt;&#x3D;nbytes\n* @return: 成功，返回从文件中实际读到的字节数 当读到文件结尾时，则返回0\n*          出错，返回-1\n*&#x2F;\nsize_t read(int fd, void *buff, size_t nbytes)\n\n\n写 write\n  #include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para fd: 文件描述符\n* @para buff: 指向缓冲区，存放了需要写入文件的数据\n* @para nbytes: 需要写入文件的字节数\n* @return: 成功，返回实际写入文件的字节数\n*          出错，返回-1\n*&#x2F;\nsize_t write(int fd, const void *buff, size_t nbytes);\n\n\n关闭 close\n  #include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para fd: 文件描述符\n* @return: 成功，返回0\n*          出错，返回-1\n*&#x2F;\nint close(int filedes);\n\n\n删除 unlink\n  #include &lt;unistd.h&gt; \n\n&#x2F;**\n* @para path: 要删除文件的路径\n* @return: 成功，返回0\n*          出错，返回-1\n*&#x2F;\nint unlink(char* path);\n\n\n文件描述符的属性控制\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys&#x2F;types.h&gt;\n\nint result&#x3D;fcntl(int fd,int cmd);\nint result&#x3D;fcntl(int fd,int cmd,long arg,...);\n\n\ncmd\n含义\n\n\n\n\nF_DUPFD\n复制文件描述符\n\n\nF_GETFD\n获得文件描述符\n\n\nF_SETFD\n设置文件描述符\n\n\nF_GETFL\n获取文件描述符当前模式\n\n\nF_SETFL\n设置文件描述符当前模式\n\n\nF_GETOWN\n获得异步I/O所有权\n\n\nF_SETOWN\n设置异步I/O所有权\n\n\nF_GETLK\n获得记录锁\n\n\nF_SETLK\n设置记录锁\n\n\nF_SETLKW\n设置记录锁\n\n\n常见用法\n&#x2F;&#x2F;增加文件的某个flags，比如文件是阻塞的，想设置成非阻塞:\nflags &#x3D; fcntl(fd,F_GETFL,0); \t&#x2F;&#x2F;首先获取文件描述符属性\nflags |&#x3D; O_NONBLOCK; \t\t\t&#x2F;&#x2F;修改文件描述符属性，设置为非阻塞模式\nfcntl(fd,F_SETFL,flags);\t\t&#x2F;&#x2F;设置文件描述符属性\n\n&#x2F;&#x2F;取消文件的某个flags，比如文件是追加模式的， 想设置成为非追加模式:\nflags &#x3D; fcntl(fd,F_GETFL,0);\nflags &amp;&#x3D; ~O_APPEND; &#x2F;&#x2F;对追加模式取非表示取消追加模式。\nfcntl(fd,F_SETFL,flags);\n文件\\目录相关Syscall\n#include &lt;sys&#x2F;types.&gt;\n#include &lt;dirent.h&gt;\n\n&#x2F;**\n* 打开目录，返回一个指向DIR的指针，从而创建一个到目录的连接\n*&#x2F;\nDIR *opendir(const char *dir_name); \n\n&#x2F;**\n* 每次从DIR中读取目录项信息，该目录信息保存在结构体dirent中 \n*&#x2F;\nstruct dirent&#123;\n    char d_name[1];\t&#x2F;* 文件名称 *&#x2F;\n\tint d_fileno; \t&#x2F;*文件的inode号*&#x2F;\n&#125;;\nstruct dirent * readdir(DIR *dir); \n\n&#x2F;**\n* 目录的定位\n*&#x2F;\nvoid seekdir(DIR *dir, off_t offset);\noff_t telldir(DIR *dir);\nvoid rewinddir(DIR *dir);\n\n&#x2F;**\n* 目录的创建&#x2F;删除&#x2F;改变&#x2F;获得\n*&#x2F;\nint res&#x3D;mkdir(char*pathname,mode_t mode);\nint res&#x3D;rmdir(char*pathname);\nint res&#x3D;chdir(const char* path);\nchar *getcwd(char *buf, size_t size);\n\n&#x2F;**\n* 目录或者文件重命名,同时可以改变位置\n* 本质只是将链接移动到另外一个目录\n*&#x2F;\nint res&#x3D;rename(const char*from,const char *to);\n&#x2F;&#x2F; eg\nrename(&quot;y&quot;,&quot;c&#x2F;d2&#x2F;y.old&quot;);\n\n&#x2F;**\n* 文件与目录的属性\n*&#x2F;\n#include &lt;sys&#x2F;stat.h&gt; \nint result&#x3D;stat(char *fname,struct stat *bufp);\nint lstat(const char *restrict path, struct stat *restrict buf);\nint fstat(int fildes, struct stat *buf);\n\nstruct stat &#123; \n    dev_t st_dev;\t&#x2F;*包含该文件的设备ID号*&#x2F; \n    ino_t st_ino;\t&#x2F;*文件的inode file serial number*&#x2F;\n\tmode_t st_mode;\t\t&#x2F;*文件类型及权限模式*&#x2F; \n    nlink_t st_nlink;\t&#x2F;*该文件的链接数*&#x2F;\n\tuid_t st_uid;\t&#x2F;*文件所有者的用户ID*&#x2F;\n\tgid_t st_uid;\t&#x2F;*文件的组ID*&#x2F;\n\tdev_t st_rdev;\t&#x2F;*如果文件为字符或者块设备时的设备ID*&#x2F; \n    off_t st_size;\t&#x2F;*若文件为普通文件，文件的字节数*&#x2F;\n\ttime_t st_atime; &#x2F;*最近的访问时间*&#x2F; \n    time_t st_mtime; &#x2F;*最近数据修改时间*&#x2F; \n    time_t st_ctime; &#x2F;*最近文件状态改变的时间*&#x2F;\n&#125;\n\n链接\n目录文件中存储的是文件名称及所对应的 inode，它被称为链接。不同的文件名可以对应同一个inode，链接数是指向该inode的文件数。\n链接分为硬链接和符号链接，这篇文有具体介绍它们的区别。评论区有一句话总结的挺好：文件名本身是指针，硬链接是和文件名同一级别的指针，软链接(符号链接)是指向指针的指针。\n下面是使用方法\n# 硬链接\nln testfile hard_link\n# 软连接(符号链接)\nln -s testfile softlink\n文件IO和标准IO的区别\n详见此文\n\n\n文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。\n\n\n通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销\n\n\n文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。\n\n\n\n\n标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。\n\n\n标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。\n\n\n标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。\n\n\n\n\n","thumbnail":"https://images.unsplash.com/photo-1519052537078-e6302a4968d4?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","plink":"http://blog.horik.cn/2022/10/04/「系统编程」文件操作/"},{"title":"「nginx」学习笔记","date":"2022-09-30T19:36:35.000Z","date_formatted":{"ll":"Sep 30, 2022","L":"09/30/2022","MM-DD":"09-30"},"updated":"2022-10-02T21:40:11.044Z","content":"大部分内容在课件里面都有写了，这里记录一些比较重要的点\nnginx介绍\nNginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。\nnginx原理\n\nnginx has one master process and several worker processes. The main purpose of the master process is to read and evaluate configuration, and maintain worker processes. Worker processes do actual processing of requests. nginx employs event-based model and OS-dependent mechanisms to efficiently distribute requests among worker processes. The number of worker processes is defined in the configuration file and may be fixed for a given configuration or automatically adjusted to the number of available CPU cores\n\nnginx在启动后系统运行一个master process，这个进程的作用是查看配置文件并维护worker process。nginx中真正起到转发请求作用的其实是这些worker process。master process通过阅读配置文件得知用户规定了哪些server，每一个server对应着一个worker process。所以学会使用nginx，其实就是学会写nginx的配置文件。\n查找nginx相关进程\nps -aux | grep nginx\n查看nginx的错误日志\n\n出了问题不要慌，打开日志看一下\n\n查看日志的时候需要从尾部开始查看\ntail -f &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log\n配置静态网页\n# curl http:&#x2F;&#x2F;localhost:80 会访问这个\nserver &#123;\n    listen       80;\t# 监听的端口\n    server_name  localhost;\t\t# 区分server的标识符\n\n    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log  main;\n\n    location &#x2F; &#123;\n        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;\n        index  index.html index.htm;\n    &#125;\n\n# curl http:&#x2F;&#x2F;nginx-dev:80 会访问这个\nserver&#123;\n    listen 80;\n    server_name nginx-dev;#主机名\n    \n    location &#x2F; &#123;\n        root &#x2F;home&#x2F;AdminLTE-3.2.0;\n        index index.html index2.html index3.html;\n    &#125;\n  \n&#125;\n\nReference：\nnginx一小时精讲\n配套课件\t\n官方Guide\n\n","plink":"http://blog.horik.cn/2022/09/30/「nginx」学习笔记/"},{"title":"「系统编程」Shell编程FAQ","date":"2022-09-27T16:32:17.000Z","date_formatted":{"ll":"Sep 27, 2022","L":"09/27/2022","MM-DD":"09-27"},"updated":"2022-10-25T22:28:57.333Z","content":"[TOC]\n\n&lt;FAQ&gt;:= &lt;Basic&gt; + &lt;Cooooool&gt;\n年轻人的自动化脚本启航之旅——shell编程！运行一个脚本，命令行开始跳动不明意义的字符，不觉得这很酷吗？作为一名理工男我觉得这实在是太酷了，很符合我对未来生活的想象，科技并带着趣味…\n\n\n基本语法约定\nbash脚本内容：\n# 这是一行注释，以#号开头\n\n# 下面这一行不是注释，它的作用是指明脚本使用的解释器，让脚本能跑起来\n#!&#x2F;bin&#x2F;bash\n\n# 每一行是一个命令\necho &quot;hello&quot;\n\n# 可以用&lt;;&gt; 在同一行使用多个命令\necho &quot;new&quot;; echo &quot;world&quot;\n\n# 逗号连接了一串运算式子，把最后一个表达式的值返回给左值（不觉得拆开写更有可读性吗？奇怪的语法）\nlet &quot;t2 &#x3D; ((a &#x3D; 9, 15 &#x2F; 3))&quot;\necho t2\t# 结果为5\n\n# 转义符号是反斜杠\necho &quot;\\&quot;&quot;\n\nexit 0\t# 正常结束脚本，非0为异常结束\n命令行内容：\n# 运行脚本--方式1\nsh &lt;scriptname&gt; # 禁用了脚本stdin中读数据的功能(不推荐)\n\n# 运行脚本--方式2\nbash &lt;scriptname&gt;\n\n# 运行脚本--方式3\nchmod [555|+rx|u+rx] &lt;scriptname&gt;\t# 脚本必须具有可执行权限\n.&#x2F;&lt;scriptname&gt;\t\t# 对了,bash脚本以.sh作为后缀名\n\n# 查看脚本的退出码\necho $?\t# $?可以读取上一条命令（上一个程序）的退出码\n变量\n环境变量\n环境变量就是工作环境(系统)下的全局变量（本质上就是已经提前定义好的变量）\nHOME 用于保持注册目录的完全路径名\nPWD 当前工作目录的绝对路径\nPS1 主提示符，特权用户是#，普通用户是$。\n定义环境变量\nexport environment_variable&#x3D;xxxxx\n使用上面这个语句，当你退出当前的 Terminal，再次打开一个新的 Terminal 时，将无法再次访问 system_programming 。这是因为，我们上次进行的修改，是在一个 bash 的进程中修改的，当我们关闭 Terminal，就终止了这个进程；当再次启动一个新的 Terminal 时，就重新开启了一个新的进程，这个新的进程自然是访问不到别的进程的变量的。\n当一个 bash 进程启动时（即，打开一个 Terminal 或者远程 SSH 登录时），该进程会读取 ~/.bashrc 文件来完成初始化。因此，我们只需要把上面提到的 export\n语句写到 ~/.bashrc 文件中就可以了。\n为了达到所有用户都可以访问的效果，我们可以把 export 语句写 到 /etc/profile 文件，当系统启动时会读取到该文件。\n使用C语言获取环境变量\n可以使用全局变量environ获取所有的环境变量：\n# include &lt;stdio.h&gt;\nextern char** environ;\nint main(int argc, char const* argv[]) &#123;\n    char** p &#x3D; environ;\n    for (; *p !&#x3D; NULL; p++) &#123;\n        printf(&quot;%s\\n&quot;, *p);\n    &#125;\n    return 0;\n&#125;\n还可以使用函数getenv() 返回特定的环境变量的值：\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char const *argv[]) &#123;\n    const char* envName &#x3D; &quot;SHELL&quot;;\n    printf(&quot;$SHELL &#x3D; %s\\n&quot;, getenv(envName));\n    return 0;\n&#125;\n用户变量\n# 定义变量\n&lt;var_name&gt;&#x3D;&lt;var_value&gt;\t# 这里的等号旁边不能加空格（貌似脚本语言对缩进、空格的要求都挺高的，我猜这是为了方便写解释器）\nreadonly &lt;var_name&gt;&#x3D;&lt;var_value&gt; # 只读的变量（感觉没啥用）\n# 使用变量\n$&lt;var_name&gt;\t\t\t# 我喜欢这种，写起来简单\n$&#123;&lt;var_name&gt;&#125;\t\t# 支持数组\n&quot;$&lt;var_name&gt;&quot;\t\t# 防止变量中含空格造成错误\n&quot;$&#123;&lt;var_name&gt;&#125;&quot; \t# 支持数组且支持空格\n\n# 例子\nvar1&#x3D;1\nvar2&#x3D;$&#123;var1&#125;\necho $&#123;var2&#125;\n&gt;&gt; 1\necho $var2\n&gt;&gt; 1\n# 错误例子\n\nvar &#x3D; 1\t# 变量赋值不能有空格\n&gt;&gt; [ERROR!] var：未找到命令\n奇怪的引号机制\n第一次接触shell的时候在引号这里踩了坑，这里记录一下不同引号的作用\n单引号\n单引号括起来的字符均作为普通字符出现。\nstring&#x3D;&#39;$PATH&#39; \necho $string\n&gt;&gt;$PATH # string被视为了纯字符串\n双引号\n双引号括起来的字符除$、\\、'、和&quot;之外都将作为普通字符对待。\nstring&#x3D;&quot;$PATH&quot;\necho $string\n&gt;&gt; &#x2F;usr&#x2F;bin:&#x2F;root\t# string内的path被视为了命令\n反引号\n后置引用，命令替换。其所括字符串在被Shell解释时，首先执行其中的命令，并将其结果代替该命令\npwd \n&gt;&gt; &#x2F;root\nstring&#x3D;&quot;current directory is &#96;pwd&#96;&quot; \necho $string\n# string中的pwd被命令执行的结构替换了\n&gt;&gt; Current directory is &#x2F;root\n引号嵌套\n从最外层开始解释\n#!&#x2F;bin&#x2F;bash\nB&#x3D;&#96;cat b.c|grep 234&#96;\necho $B\necho &#39;$B&#39;\n&gt;&gt; 1234\n&gt;&gt; $B\t# 外层的单引号&#39;&#39;让变量B没机会替换其定义的内容（个人理解）\n命令行参数\n内部变量\n$#`和`$*是比较常用的内部变量，可以帮助脚本接受来自命令行的参数信息（args）\n$# 传递给脚本参数的数量\n$* 所有传递给脚本的参数内容 \n$? 上条命令执行后返回的状态 \n$$ 当前进程的进程号→最常见的用途是作为暂存文件的名称，以保证不会重复。\n$! 后台运行的最后一个进程号 \n$0 当前执行的进程名\n\n@ 它是\n\n\n\n\n \n\n它\n\n\n是\n\n\n*的另外一种形式，它不使用IFS。\nIFS是什么？\n$ IFS='' \t# IFS用于设置`$*&#96;多参数之间的分隔符\n$ set foo bar bam \n\n echo \"\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n@&quot; \nfoo bar bam \n\n echo \"\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n*&quot;\nfoobarbam \n$ unset IFS \n\n echo \"\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n*&quot;\nfoo bar bam\n位置参数\n在命令行中按照各自的位置决定的变量，程序名之后输入的参数，之间用空格分割，第 一个参数可使用\\\n1取得，以此类推，\\\n\n\n\n\n \n\n取\n\n\n得\n\n\n，\n\n\n以\n\n\n此\n\n\n类\n\n\n推\n\n\n，\n\n\n0表示当前Shell程序的进程名。共10个位置参数变量，从程序名开始依次为 第0~9个\n#!&#x2F;bin&#x2F;bash\necho &quot;The name of this script is \\&quot;$0\\&quot;.&quot;\nif [ -n &quot;$1&quot; ]; then\n    echo &quot;Parameter #1 is $1&quot;\nfi\nif [ -n &quot;$2&quot; ]; then\n    echo &quot;Parameter #2 is $2&quot;\nfi\n.&#x2F;test.sh 114\nThe name of this script is &quot;.&#x2F;test.sh&quot;.\nParameter #1 is 114\n怎么使用超过十个位置呢？我们使用shift命令，shift 命令重新分配位置参数,其实就是向左移动一个位置\n#!&#x2F;bin&#x2F;bash\nuntil [ -z “$1” ]; do # 直到所有参数都用完\n    echo -n &quot;$1 &quot;\n    shift\ndone\n参数置换变量\n有些参数我们会给定一些默认值，同时也开放接口支持用户在命令行提供参数修改默认值，这时候就要用到参数置换变量的语法了（虽然我感觉用 **if **判断也挺好）。下面这个例子中，如果脚本中没有命令行参数 ,那么default parameter将被使用。\n#！&#x2F;bin&#x2F;bash \nDEFAULT_FILENAME&#x3D;generic.data filename&#x3D;${1:-$DEFAULT_FILENAME&#125;\necho $filename\n.&#x2F;test.sh\n&gt;&gt; generic.data\n.&#x2F;test.sh abc\n&gt;&gt; abc\n上面的参数置换变量的语法有几种变体，它们的区别在于没有设置参数时的行为，需要的时候自查\n运算\n#!&#x2F;bin&#x2F;bash \nx&#x3D;0 \nwhile [ &quot;$x&quot; -ne 10 ]; do \n\techo $x \n\tx&#x3D;\n((\n\n\n\n\n \n \n\nx+1)) \t# shell中使用$((&lt;exp&gt;))包裹表达式，让解释器知道这里要解释为运算\ndone\nexit 0\n\n\n# 另外一种方式，使用expr字段，没有括号方便，不推荐\nx&#x3D;\n(expr \n\n\n\n\n\n\n\n\n \n \n \n \n \n\nx +1)\n字符串操作\n字符串长度\nexpr length $stringZ\nexpr &quot;$stringZ&quot; : &#39;.*&#39;\t# 这里其实是子串匹配的特殊情况(正则表达式匹配了所有字符)\n$&#123;#stringZ&#125;\t\t# #号的意思是集合内元素的个数(在这里就是字符串的长度)\n\n|---例子---|\nstringZ&#x3D;abcABC123ABCabc\n$&#123;#stringZ&#125;\nexpr length $stringZ\nexpr &quot;$stringZ&quot; : &#39;.*&#39;\n匹配子串长度\n从字符串开始的位置匹配子串的长度\nexpr match &quot;\nstring\" '\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n \n \n\n\nsubstring’\t# $substring 是一个正则表达式\nexpr match &quot;$string\" '\\($substring\\)&#39;\nexpr &quot;\nstring\" : '\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n \n\n\nsubstring’\n\n|---例子---|\necho &#96;expr match &quot;$stringZ&quot; &#39;abc[A-Z]*.2&#39;&#96; \n&gt;&gt; 8 # abcABC12\necho &#96;expr &quot;$stringZ&quot; : &#39;abc[A-Z]*.2&#39;&#96;\n&gt;&gt; 8 # abcABC12\necho &#96;expr match &quot;$stringZ&quot; &#39;abc[A-Z]*&#39;&#96; \n&gt;&gt; 6 # abcABC\n索引匹配\n匹配到子串的第一个字符出现的位置，注意\n\n索引从1开始\n子串是单个字符的集合，索引匹配的机理是：在母串顺序查找字符x，如果x在字串出现过，就停止查找，返回x的索引\n\nexpr index \nstring \n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\nsubstring\n\n|---例子---|\nstringZ&#x3D;abcABC123ABCabc \necho &#96;expr index &quot;$stringZ&quot; C12&#96;\n&gt;&gt; 6\necho &#96;expr index &quot;$stringZ&quot; 1c&#96; \n&gt;&gt; 3\necho &#96;expr index &quot;$stringZ&quot; 2c&#96; \n&gt;&gt; 3\necho &#96;expr index &quot;$stringZ&quot; b2c&#96; \n&gt;&gt; 2\necho &#96;expr index &quot;$stringZ&quot; a45c&#96;\n&gt;&gt; 1\n子串提取\nexpr substr \nstring \n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\nposition $length\n# 在 string 中从位置\nposition 开始提取子串. 如果\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n开\n\n\n始\n\n\n提\n\n\n取\n\n\n子\n\n\n串\n\n \n\n如\n\n\n果\n\n\nstring为“*”或“@”,那么将提取从位置$position 开始的位置参数\n$&#123;string:position&#125;\n# 在 string 中从位置\nposition 开始提取\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n开\n\n\n始\n\n\n提\n\n\n取\n\n\nlength 长度的 子串.\n$&#123;string:position:length&#125;\n# $position可以取负数，将从字符结尾开始,反向提取子串 需要加上圆括号转义\n$&#123;stringZ:(-4)&#125;\n子串删除\nstringZ&#x3D;abcABC123ABCabc\n[1]\n# 从\nstring 的左边截掉 第一个匹配的 \n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n的\n\n\n左\n\n\n边\n\n\n截\n\n\n掉\n\n\n第\n\n\n一\n\n\n个\n\n\n匹\n\n\n配\n\n\n的\n\n\nsubstring\n$&#123;string#substring&#125; \necho $&#123;stringZ#a*C&#125; \n&gt;&gt; 123ABCabc\n\n[2]\n# 从\nstring 的左边截掉最后一个匹配的\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n的\n\n\n左\n\n\n边\n\n\n截\n\n\n掉\n\n\n最\n\n\n后\n\n\n一\n\n\n个\n\n\n匹\n\n\n配\n\n\n的\n\n\nsubstring\n$&#123;string##substring&#125; \necho $&#123;stringZ##a*C&#125; \n&gt;&gt; abc\n\n\nstringZ&#x3D;abcABC123ABCabc\n[3]\n# 从$stringZ 的后边开始截掉&#39;b&#39;和&#39;c&#39;之间的最近的匹配\necho $&#123;stringZ%b*c&#125;\n&gt;&gt; abcABC123ABCa\n[4]\n# 从$stringZ 的后边开始截掉&#39;b&#39;和&#39;c&#39;之间的最远的匹配\necho $&#123;stringZ%%b*c&#125;\n&gt;&gt; a\n子串替换\n# &#x2F; 替换第一个匹配的$substring.\n$&#123;string&#x2F;substring&#x2F;replacement&#125;\n# &#x2F;&#x2F; 替换所有匹配的$substring\n$&#123;string&#x2F;&#x2F;substring&#x2F;replacement&#125;\n\n# 如果\nsubstring 匹配\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n匹\n\n\n配\n\n\nstring 的开头部分,那么就用 \nreplacement 来替换\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n来\n\n\n替\n\n\n换\n\n\nsubstring.\n$&#123;string&#x2F;#substring&#x2F;replacement&#125; \n# 如果\nsubstring 匹配\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n匹\n\n\n配\n\n\nstring 的结尾部分,那么就用 \nreplacement 来替换\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n来\n\n\n替\n\n\n换\n\n\nsubstring.\n$&#123;string&#x2F;%substring&#x2F;replacement&#125; \n条件语句\n条件Condition的写法\n# 在中括号内写条件语句(推荐)\n[condition]\n# 在test命令后写条件语句\ntest condition\n\n# 字符串--条件语句\n[str1&#x3D;str2]\n[str1!&#x3D;str2]\n[str]\t# true iff str不是空字符\n-n str\t# true iff len(str) &gt; 0\n-z str\t# true iff len(str) &#x3D;&#x3D; 0\n\n# 整数--条件语句\nint1 -eq int2\t# equal\nint1 -ge int2\t# greater than\nint1 -le int2\t# less and equal\nint1 -gt int2 \t# great than and equal\nint1 -ne int2 \t# not equal\n\n# 文件--条件语句\n-d file\t\t# directory\n-f file \t# normal file\n-r file\t\t# readable\n-s file\t\t# strlen(file)&gt;0\n-w file\t\t# writable\n-x file \t# executable\n\n# 逻辑符\n!expr \t# 取反 \nexpr1 -a expr2 \t# and\nexpr1 -o expr2\t# or\n条件控制流的写法\nif else\n#!&#x2F;bin&#x2F;bash \nif [ $1 -le 10 ];then\n\techo “a&lt;&#x3D;10”\nelif [ $1 –le 20 ];then\n\techo “10&lt;a&lt;&#x3D;20”;\nelse\n\techo “a&gt;20”;\nfi\ncase\n#!&#x2F;bin&#x2F;sh \necho “Is it morning? Please answer yes or no” \nread timeofday \t\t\t#等待用户输入 \ncase &quot;$timeofday&quot; in \nyes | y | Yes | YES） \t# 条件1\n\techo &quot;Good Morning&quot; \n\techo “Up bright and early this morning”\n[nN]*)\t\t\t\t\t# 条件2\n\techo “Good Afternoon” ;;\n*)\t\t\t\t\t\t# 用*通配符来处理无匹配项情况\n\techo “Sorry, answer not recognized” echo “Please answer yes or no” exit 1 ;;\nesac\t\t\t\t\t# 结束case判断\nexit 0\n逻辑运算\n支持短路运算\n||\n&amp;&amp;\n循环语句\nwhile\nwhile [condition]; do \n\tcommand(s)\ndone\nUtill\nuntil [condition]; do \n\tcommand(s)\ndone\nfor\nfor arg in [list]; do \t# list 中的参数允许包含通配符\n\tcommand(s)\ndone\n数组\narea1[13]&#x3D;1 \t# 初始化数组，可以跳着初始化，数组成员不必一定要连贯或连续的，空缺元素是允许的\narea2&#x3D;( zero one two three four ) # 初始化数组，数组下标从零开始\narea3&#x3D;([17]&#x3D;seventeen [24]&#x3D;twenty-four)\t# 初始化数组，指定位置\n\necho $&#123;area2[0]&#125;\t# 访问数组\n函数\n函数必须先定义再调用,调用的时候直接写函数名就可以了\n[function] function_name ()&#123;\n\tcommands(s)\n&#125; \n那传参和返回值怎么办呢?\n\n调用函数的时候在后面加上参数, 使用位置参数 \\\n1 \\\n\n\n\n\n \n\n2 等进行取参\n返回值使用 $? 获得\n\nmax 1 2 3\necho $?\nPATH\n当大家在工作目录中使用 GCC 编译出来了一个可执行文件a.out，要运行这个程序的时候是这样进行的：\n.&#x2F;a.out\n或者，直接\na.out\n这两个都是一样的，都是直接在 shell 中输入了要执行的文件的文件名。这是在 bash shell 中执行可执行文件的唯一方式。\n但如果我们不在这个可执行文件所在的目录下怎么办？如果我在一个其他目录下，想执行这个程序，就需要用相对路径或绝对路径写出整个路径前缀，这往往是一件非常麻烦的事情。这时候，PATH就诞生了。\nPATH是一个环境变量，这个环境变量指明了系统默认的查找可执行文件的路径。你可以在 bash shell 中使用echo $PATH打印出你当前的PATH，它将如下所示：\n&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin\n这一行输出实际上是几个路径之间用:拼接起来的。\n有了PATH，当你在命令行输入一个程序名时，bash shell 就会去PATH所指定的这几个目录中去寻找该程序，如果找不到就会报错。\n现在大家知道了吧，我们平常使用的指令ls、mv等指令没啥神奇的，他们只不过是操作系统预设好的一个个程序，并放在了PATH指定的某个路径下，我们输入指令时，其实就相当于是在执行这些程序。\n比如，我们可以用which来查看这些“内置程序”的具体路径\n这一点可以去路径/usr/bin下去查看验证一下。\n调试\nbash没有调试工具，只提供了几个辅助参数\nsh -n scriptname # 不会实际运行脚本,而只是检查脚本的语法错误，该方法不能检测所有的语法错误。\nsh -v scriptname # 在实际执行一个命令前打印出这个命令.\nsh -x scriptname # 打印每个命令的执行结果, 但只用在某些小的方面.\n真正调试的时候依赖于printf大法，在各个位置使用echo打印信息，高级一点可以在编写程序阶段就使用assert\nTrap\n在程序退出之前可以加一个hook（钩子函数），执行一系列的动作后再退出程序。原理是exit发出一个信号signal，在我们设置特定的trap后，这种信号会触发trap（类似中断），执行trap的处理函数。这常用来捕捉exit 命令做某事, 如强制打印变量值\n# trap 命令必须是脚本中的第一个命令。\n#!&#x2F;bin&#x2F;sh \ntrap ‘rm -f &#x2F;tmp&#x2F;my_tmp_file’ INT \necho creating file &#x2F;tmp&#x2F;my_tmp_file\ndate &gt; &#x2F;tmp&#x2F;my_tmp_file \necho “press interrupt (CTRL-C) to interrupt ....” \nwhile [ -f &#x2F;tmp&#x2F;my_tmp_file ]; do \n\techo File exists sleep 1 \ndone\necho The file no longer exists\n信号量一览\n\n\nSignal\nDescription\n\n\n\n\nHUP\n挂起\n\n\nINT\nCtrl+C引发的中断\n\n\nQUIT\nCtrl+\\引发的退出\n\n\nABRT\n严重执行错误引发的中止\n\n\nALRM\n定时处理的报警信号\n\n\nTERM\n终止，系统关机时发送\n\n\n\n好啦，你已经学会shell编程辣！！！现在快用shell手搓一个快排吧\n\nFLAG：感觉比较重量级的bash脚本是用来跑文件批处理的（自动化测试|批量运行|批量重命名），python也能干这活儿，不知道有什么优劣区别，有机会实践一下再POST一篇新内容吧\n\n\n\nReference\n[1] BUAA系统编程课程第三章PPT–01 Shell编程\n[2] 系统编程课程指导书（非常好指导，爱来自助教）\n\n","thumbnail":"https://images.unsplash.com/photo-1629624927838-3b39b7fdd33c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1169&q=80","plink":"http://blog.horik.cn/2022/09/27/「系统编程」Shell编程FAQ/"},{"title":"「系统编程」动态链接库的创建和使用","date":"2022-09-14T22:51:53.000Z","date_formatted":{"ll":"Sep 14, 2022","L":"09/14/2022","MM-DD":"09-14"},"updated":"2022-09-29T20:05:29.627Z","content":"鸽鸽鸽~\n","plink":"http://blog.horik.cn/2022/09/14/「系统编程」动态链接库的创建和使用/"},{"title":"「系统编程」Linux工具链","date":"2022-09-08T14:37:41.000Z","date_formatted":{"ll":"Sep 8, 2022","L":"09/08/2022","MM-DD":"09-08"},"updated":"2022-10-01T15:59:32.000Z","content":"GNU 工程开发了大量用于 Unix 的自由软件工具，其中GNU工具链（英语：GNU toolchain）是一个包含了由GNU计划所产生的各种编程工具的集合，由自由软体基金会负责维护工作。这些工具形成了一条工具链，用于开发应用程序和操作系统。\n\n\nHint 1\n自由软件意味着使用者有运行、复制、发布、研究、修改和改进该软件的自由。\n\n\nHint 2\n“GNU”这个名字是“GNU’s Not Unix”的递归首字母缩写词。“GNU”的发音为g’noo，只有一个音节，发音很像“grew”，但需要把其中的r音替换为n音。\n\n这篇文章是对GNU工具链中的编译套件（gcc），调试工具（gdb），构建和管理工具（make）的常用功能陈列。其实网上已经有很多这种总结帖子了，按照不重复造轮子的原则，我其实不应该花时间来做这个总结的。但我这刚开博客坑没几天，好歹得有点产出吧（笑，写写这种东西也不费事儿，纯当写memo备忘了。另外，如果你想上手工具的话，最好的办法是先有个大概了解，心里有谱了就可以上手用了，需要用什么再查什么。事实上，读or写这种文档就像是学英语背牛津词典一样，味同嚼蜡（这是最后一篇重复造轮子的文章 &gt;_&lt; ）\nGCC - 基于C/C++的Compiler\ngcc的全称是GNU Compiler Collection,即GNU编译器套件.它的初衷是为了给GNU操作系统专门写一款编译器,以解决不同GNU系统间编译器混乱的问题，现在,它已经可以编译众多语言,例如C, C++, Objective-C, Fortran, Ada, Go.并且成为了C, C++编译器的首选。\ngcc是编译器套件，它提供了编译的全过程工具。\n\n编译的四个阶段\n如上图所示，广义上的C语言编译过程分为4个阶段，gcc编译器套件也对应为了四个部件：\n\n\n预处理器 cpp\n主要完成三项工作：将原文件中的头文件展开，宏替换，去注释\n  ~$&gt; gcc -E hello.c hello.i\n\n\n编译器 gcc\n将C语言代码翻译为汇编语言代码\n  ~$&gt; gcc -S hello.i hello.s\n\n\n汇编器 as\n将汇编语言代码翻译为二进制的可重定位文件\n  ~$&gt; gcc -c hello.s -o hello.o\n\n\n链接器 ld\n将函数库中的代码组合到目标文件中\n  ~$&gt; gcc hello.o -o a\n\n\ngcc常用参数\n有了以上四个阶段的认识以后，我们再来介绍gcc的常用参数\n-o：指定生成的输出文件名字；\n-E：仅执行编译预处理；\n-S：将C代码转换为汇编代码；\n-wall：显示警告信息；\n-c：仅执行编译操作，不进行连接操作。\n-I：给出头文件的目录路径\n-g: 保留调试需要使用的信息，需要gdb调试的时候使用此选项\n-O: 编译的优化等级，未指定时默认不优化，O0\\O1\\O2\\O3优化效果逐步递增\n-D name: 编译时宏定义。在编译时预定义名称为name的宏，源代码中的name被替换为1\n-l：用来指定程序要链接的库，-l参数紧接着就是库名\n-L: dir选项。该选项将dir添加到库文件搜索路径中\n-static: 该选项表示在编译时强制使用对应的静态链接库\n-shared: 该选项创建共享库。它所创建的动态库文件以.so后缀结尾。\n-ansi: 等价于-std&#x3D;c89。该选项指定源程序使用ISO C90标准\n-std&#x3D;: 它确定源程序中所使用的C语言标准\n给出一些实例，如果你都能看明白就会用gcc了，如果存有疑问，请查看https://wangchujiang.com/linux-command/c/gcc.html\n# 无选项编译链接\n~$&gt; gcc test.c\n# 选项 -o\n~$&gt; gcc test.c -o test\n# 选项 -E\n~$&gt; gcc -E test.c -o test.i\n# 选项 -S\n~$&gt; gcc -S test.i\n# 选项 -c\n~$&gt; gcc -c test.s\n# 无选项链接\n~$&gt; gcc test.o -o test\n# 选项 -O\n~$&gt; gcc -O1 test.c -o test\n# 选项 -D\n~$&gt; gcc -DDEBUG -o debug debug.c\n~$&gt; gcc -DDEBUG&#x3D;0 -o debug debug.c\n# 选项 -I dir 将 dir 增加至头文件搜索路径\n~$&gt; gcc test.c –I..&#x2F;inc -o test\n~$&gt; gcc hello.c -lpthread -I &#x2F;lib64&#x2F; -o hello\n# 选项 -L dir 将 dir 增加至库文件搜索路径\n# 选项 -I library 指定编译时搜索的库名\n~$&gt; gcc hello.c -L . -lpthread -I &#x2F;lib64&#x2F; -o hello\n\n# 多文件编译--plan A\n~$&gt; gcc testfun.c test.c -o test\n# 多文件编译--plan B\n~$&gt; gcc -c testfun.c    #将testfun.c编译成testfun.o\n~$&gt; gcc -c test.c       #将test.c编译成test.o\n~$&gt; gcc testfun.o test.o -o test    #将testfun.o和test.o链接成test\n\n# 生成静态链接库\n~$&gt;  cd test\n~$&gt;  gcc -c *.c\n~$&gt;  ar rcs libtest.a *.o\n\n# -fPIC PIC 指 Position Independent Code\n# -share 生成一个共享对象，可以与其他对象链接以形成可执行文件。\n# 从源文件生成动态链接库\n~$&gt; gcc -fPIC -shared func.c -o libfunc.so\n# 从目标文件生成动态链接库\n~$&gt; gcc -fPIC -c func.c -o func.o\n~$&gt; gcc -shared func.o -o libfunc.so\n# 加载动态链接库\n~$&gt; gcc hello.c -lpthread -o hello\n\nGDB - 功能强大的Debugger\ngdb功能介绍\n功能强大的程序调试器，gdb命令 包含在GNU的gcc开发套件中，是功能强大的程序调试器。GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。\n使用gdb的前置工作\n在使用gdb调试器之前需要完成两项准备工作：\n\n\n开启程序崩溃信息转储，将崩溃信息存储到core文件内\n\ncore文件生成路径:\t默认在输入可执行文件运行命令的同一路径下（不是可执行文件的同一路径下）\n\n使用ulimit -c命令查看core文件的生成开关。若结果为0，则表示关闭了此功能，不会生成core文件。相关命令如下：\n  ulimit -c # 查看core文件的生成开关\nulimit -c unlimited # 让程序在崩溃时产生core文件\nulimit -c filesize # 限制core文件的大小（filesize的单位为kbyte）\n\n\n在开启gdb调试之前，需要在编译源程序的时候加上-g选项\n  gcc -g test.c func.c -o test.out\n\n\n在完成以上两项准备工作后，我们就可以使用gdb来对程序调试了\ngdb test.out test.out-core # 进行调试\ngdb常用命令\n这一部分的实例介绍直接看manual： https://wangchujiang.com/linux-command/c/gdb.html，下面补充一些manual上面没有的and写的不是特别详细的：\ngdb日志\n如果你想把GDB调试过程中的屏幕显示内容保存为日志，有以下的命令与此相关（如果你看不懂下面的命令，或许可以在这里找到一点帮助：The Missing Semester of Computer Science ---- Linux 命令基础）\n(gdb) set logging on\n(gdb) set logging off\n(gdb) set logging file &lt;filename&gt;\n(gdb) set logging overwrite [on|off] &#x2F;&#x2F;默认会追加到logfile里 \n(gdb) set logging redirect [on|off] &#x2F;&#x2F;默认GDB输出会在terminal和logfile里显示，用redirect让它只在logfile里显示\n(gdb) show logging\n快照信息 checkpoint\ngdb可以在程序执行的过程中保留快照(状态)信息，称之为checkpoint，可以在进来返回到该处再次查看当时的信息，比如内存、寄存器以及部分系统状态。通过设置checkpoint，万一调试的过程中错误发生了但是已经跳过了错误发生的地方，就可以快速返回checkpoint再开始调试，而不用重启程序重新来过。（PS: 类似于游戏存档）\n(gdb) checkpoint # 在当前位置设置快照\n(gdb) info checkpoint\t# 查看所有快照点信息\n(gdb) restart checkpoint-id\n(gdb) delete checkpoint checkpoint-id\n断点 breakpoint\n在一个位置上设置断点，可以对应多个位置，gdb要自动在需要的位置插入断点。在动态库里也可以设置断点，不过其地址在加载后才能解析。 断点的设置有几种方法\n(gdb) break\n(gdb) b\t\t&#x2F;&#x2F;缩写\n(gdb) break [Function Name]\t\t&#x2F;&#x2F;函数名\n(gdb) break [File Name]:[Line Number]\t&#x2F;&#x2F;文件名的第几行 \n(gdb) break [Line Number] \t&#x2F;&#x2F;第几行\n(gdb) break *[Address]\t&#x2F;&#x2F; 想在地址0x4007d9 上设定断点 eg: break *0x4007d9\n(gdb) i line &lt;filename&gt;:&lt;line number&gt;\t&#x2F;&#x2F; 获取对应行在内存中的地址的方法\n条件断点设置\n(gdb) break [...] if [Condition]\n(gdb) break [...] thread [Thread-id]\n\neg.\n(gdb) break main if argc &gt; 1\n(gdb) break 180 if (string &#x3D;&#x3D; NULL &amp;&amp; i &lt; 0)\n(gdb) break test.c:34 if (x &amp; y) &#x3D;&#x3D; 1\n(gdb) break myfunc if i % (j+3) !&#x3D; 0\n(gdb) break 44 if strlen(mystring) &#x3D;&#x3D; 0\n(gdb) b 10 if ((int)$gdb_strcmp(a,&quot;chinaunix&quot;) &#x3D;&#x3D; 0)\n(gdb) b 10 if ((int)aa.find(&quot;dd&quot;,0) &#x3D;&#x3D; 0)\n可以用info breakpoints来查看相应断点信息\ninfo breakpoints\n变量打印 print\nprint接受表达式和计算它的值。任何该语言支持常值，变量和操作符都可以使用，像条件表达式，函数调用，类型转换，字符常量。GDB还支持数组常量，语法是{element, element…}, 比如print {1,2,3}\np[&#x2F;fmt] &lt;变量名称&gt;\n\n# fmt是print变量的格式\n设置程序中断时的观测变量 display\n设置程序中断后欲显示的数据及其格式。如果你发现你经常要打印某个表达式，你可以把它加入到“automatic display list”。每次程序停止时，都会显示\ndisplay expr\ndisplay&#x2F;fmt expr\ndisplay&#x2F;fmt addr\nundisplay &lt;dnums&gt;  delete display dnums\ndisable display dnums\nenable display dnums\n\n# 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令\ndisplay &#x2F;i $pc\n# 其中 $pc 代表当前汇编指令，&#x2F;i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。\n监视变量变化，并且在变化时停止程序 watch\n监视点是监视特定内存位置、特定表达式的值是否改变而触发程序暂停执行，而不用去关心该值到底在代码的哪个位置被修改的。监视的表达式可以是：某个变量的引用、强制地址解析(比如(int )0x12345678，你无法watch一个地址，因为地址是永远也不会改变的)、合理的表达式(比如a-b+c/d，gdb会检测其中引用的各个变量)。\nwatch [-l|-location] expr [thread thread-id] [mask maskvalue]\n\n# -location会让gdb计算expr的表达式，并将计算的结果作为地址，并探测该地址上的值\n\nwatch命令还存在两个变体：读监视点rwatch当expr被程序读的时候触发中断；读写监视点awatch会在程序读取或者写入expr的时候被中断\n查看调用栈 bt\n(gdb) bt\n#0 level0 () at recursion.cpp:5\n#1 0x08048462 in test (level&#x3D;0) at recursion.cpp:17\n#2 0x0804845b in test (level&#x3D;1) at recursion.cpp:14\n#3 0x0804845b in test (level&#x3D;2) at recursion.cpp:14\n#4 0x0804845b in test (level&#x3D;3) at recursion.cpp:14\n#5 0x0804845b in test (level&#x3D;4) at recursion.cpp:14\n#6 0x0804845b in test (level&#x3D;5) at recursion.cpp:14\n#7 0x08048479 in main () at recursion.cpp:22\n\n(gdb) bt -2\n#6 0x0804845b in test (level&#x3D;5) at recursion.cpp:14\n#7 0x08048479 in main () at recursion.cpp:22\n帧信息 frame\nframe用来显示当前帧的信息 基本语法是\nframe\nframe [Frame number]\nf\ninfo|i frame # 相比直接的frame，这个命令输出更详细的stack frame信息\n查看源代码 list *$pc*\nlist *$oc\ninfo line\n程序信息查看 info\ninfo registers | i reg\ninfo &lt;variables&gt; | i &lt;var&gt; # 可以用 i var 来查看某个全局或者静态变量在哪个文件定义的\ninfo locals # 显示当前帧的函数的ju&#39;bu\ninfo args # 显示当前帧的函数的参数， 配合frame，up和down来使用\ninfo func # 显示所有的函数名\ninfo files # 显示所有函数名\ninfo break # 显示断点列表，包括每个断点到达的次数\n设置变量值 set\ngdb可修改运行时的参数，并使该变量按照用户当前输入的值继续运行。\n# 在单步执行的过程中，键入命令：\nset 变量＝设定值\n\nMake - GNU的工程化编译工具\n\n无论是在linux 还是在Unix环境 中，make都是一个非常重要的编译命令。不管是自己进行项目开发还是安装应用软件，我们都经常要用到make或make install。利用make工具，我们可以将大型的开发项目分解成为多个更易于管理的模块，对于一个包括几百个源文件的应用程序，使用make和 makefile工具就可以简洁明快地理顺各个源文件之间纷繁复杂的相互关系。\n而且如此多的源文件，如果每次都要键入gcc命令进行编译的话，那对程序员 来说简直就是一场灾难。而make工具则可自动完成编译工作，并且可以只对程序员在上次编译后修改过的部分进行编译。\n因此，有效的利用make和 makefile工具可以大大提高项目开发的效率。同时掌握make和makefile之后，您也不会再面对着Linux下的应用软件手足无措了。\n\nmake是一个自动化的程序自动维护工具。它根据Makefile所描述的“依赖关系”自动决定项目的那些部分需要重新编译。\n它的维护是基于依赖推导的，也就是说如果某个源程序文件被修改，那么依赖这个源程序文件的所有目标文件，都需要重新编译。如果仅修改了某几个源文件，则只重新编译这几个源文件，如果某个头文件被修改了，则重新编译所有包含该头文件的源文件\nmake 执行步骤\n\n\n读入所有的Makefile。\n\n\n读入被include的其它Makefile。\n\n\n初始化文件中的变量。\n\n\n推导隐式规则，并分析所有规则。\n\n\n为所有的目标文件创建依赖关系链。\n\n\n根据依赖关系，决定哪些目标要重新生成。\n\n\n执行生成命令\n\n\nmakefile 书写规则\n阅读以下示例即可\n# main是target，即make最终需要创建的文件，如可执行文件和目标文件；\n# main.o hello1.o hello2.o 是这个target的dependency 通常是编译目标文件所需要的其他文件\nmain:main.o hello1.o hello2.o\n\t# 下面是生成main的command，是make执行的动作，通常是把指定的相关文件编译成目标文件的编译命令，每个命令占一行，且每个命令行起始字符必须为TAB字符\n\tgcc -o main main.o hello1.o hello2.o \n\t\nmain.o:main.c hello1.h hello 2.h \n\tgcc -c main.c\n\nhello1.o: hello 1.c hello 1.h \n\tgcc -c hello1.c \n\nhello2.o: hello2.c hello2.h \n\tgcc -c hello2.c\n\n# clean是target target也可以是要执行的动作，如clean\nclean:\n\trm main hello1.o hello2.o main.o\n执行上面这个makefile\nmake | make main\t# 生成main\nmake target \t# 选择目标\nmake clean\t# 执行清理\n# 伪目标\nall: prog1 prog2 prog3\n\nprog1: prog1.o utils.o\n\tgcc -o prog1 prog1.o utils.o\n\t\nprog2: prog2.o\n\tgcc -o prog2 prog2.o\n\t\nprog3: prog3.o sort.o utils.o\n\tgcc -o prog3 prog3.o sort.o utils.o\n\t\n# 声明clean是伪目标，防止有clean文件存在使得makefile认为此命令无需执行而使得make clean失效\n# 原因：根据依赖关系发现clean命令依赖的内容未发生变化\n.PHONY: clean\nclean:\n        rm *.o temp\n# 隐式规则\n# 根据后缀为.c的源文件使用gcc命令自动更新或者产生同名的.o文件，规则中略去产生目标文件的命令。\n# 同时，目标所依赖的文件列表中的.c文件亦可省略\nhello2.o: hello2.h\n\n# 与上面的简化版等价\nhello2.o: hello2.c hello2.h \n\tgcc -c hello2.c\nmakefile 自定义变量\nmakefile中的变量主要是为了简化文件，减少重复内容的书写，提高文件可读性。变量的机理是类似宏展开的方式。我们一般使用变量完成以下工作：\n\n存储文件名列表\n存储可执行文件名\n存储编译器标识\n存储参数列表\n\n# \\ 代表本行内容尚未结束，下一行继续写，用于缩短行的长度，增加程序可读性\n# objeckts变量存储了文件名列表，减少了重复\nobjects &#x3D; main.o kbd.o command.o display.o \\ \n\tinsert.osearch.o files.o utils.o\n\nedit : $(objects)\n \tcc -o edit $(objects)\n \nmain.o : main.c defs.h\n\tcc -c main.c\n\nkbd.o : kbd.c defs.h command.h\n\tcc -c kbd.c\n\n...\n\nclean :\n\trm edit $(objects)\nobj&#x3D; main.o hello1.o hello2.o\n\nmain: $(obj)\n\tgcc -o main $(obj)\nmakefile 内部变量\n# 当前规则的目标文件名\n$@\n\n# 成依赖列表中第一个依赖文件\n$&lt; \n\n# 比目标文件更新的以空格分隔的整个依赖的列表\n$?\n\n# 以空格分隔的所有的依赖文件\n$^：\n\n# 与$^功能相似，但包含有重复的依赖文件\n$+\n自动变量简化以后的makefile\nmain:main.o hello1.o hello2.o\n\tgcc -o \n@ \n\n\n\n\n \n\n^\n\nmain.o:main.c hello1.h hello 2.h\n\tgcc -c $&lt; \n\nhello1.o: hello 1.c hello 1.h \n\tgcc -c $&lt; \n\nhello2.o: hello2.c hello2.h \n\tgcc -c $&lt;\n\nclean:\n\trm main hello1.o hello2.o main.o\n","thumbnail":"https://oss.horik.cn/blog/header-linux-tools.jpg","plink":"http://blog.horik.cn/2022/09/08/「系统编程」Linux工具链/"},{"title":"「计算机组成原理」数制基础","date":"2022-09-07T19:09:42.000Z","date_formatted":{"ll":"Sep 7, 2022","L":"09/07/2022","MM-DD":"09-07"},"updated":"2022-09-29T21:05:51.761Z","content":"本文的核心内容是向同学们介绍计算机的数制基础。学习本文将有助于你：\n\n理解数制的基本概念，掌握进制之间的转换方法和技巧\n理解计算机二进制编码的三种解释方式：原码、反码、补码\n\n阅读完本文后，你应该至少掌握下面两张图的内容。（如果你自认为已经掌握了，可以直接跳到本文末尾的拓展阅读）\n\n\n \n数制基础准备\n\n本节的概念同学们只需要有一个感性的认识就可以，没有完全理解也不必纠结\n\n数制也称为“计数制”，是用一组固定的符号和统一的规则来表示数值的方法。任何一个数制都包含两个基本要素：基数和位权。这句话听起来可能比较抽象，请看下述示例：\n\n(810975)_{10} = 8*10^5 + 1*10^4 + 0*10^3 + 9*10^2 + 7*10^1 + 5*10^0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n \n\n\n \n\n \n \n\n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n\n\n这个例子使用了我们非常熟悉的十进制（810975右下角的角标10表明这个字符串使用的是十进制），我们借助这个例子来讲解上面的抽象概念\n\n\n基数：数制所使用数码的个数\n例如，十进制的基数是10，它的数码集合为\n\\{0, 1,2,3,4,5,6,7,8,9\\}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n位权：数制中某一位上的1所表示数值的大小（所处位置的价值/权重）\n例如，810975中的8所在位置的位权就是\n10^5\n\n\n\n\n\n\n \n \n \n\n，1所在位置的位权就是\n10^4\n\n\n\n\n\n\n \n \n \n\n，0所在位置的位权就是\n10^3\n\n\n\n\n\n\n \n \n \n\n，9所在位置的位权就是\n10^2\n\n\n\n\n\n\n \n \n \n\n，7所在位置的位权就是\n10^1\n\n\n\n\n\n \n \n \n\n，5所在位置的位权就是\n10^0\n\n\n\n\n\n \n \n \n\n\n\n\n固定的符号：数制所使用的数码\n例如，十进制数的数码集合为\n\\{0,1,2,3,4,5,6,7,8,9\\}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n，这意味着十进制数字的字符串只能由这些符号构成【实际上这里可以使用离散数学集合论中字母表和语言来形式化定义，感兴趣的同学可以在学习完离散数学Ⅱ–集合论后再回过头来看这里的例子】\n\n\n统一的规则：对数制的解释，对于一个数制来说，一旦基数和位权被定义好，就意味着由“数码“构成的符号串会被唯一地解释成一个数值\n\n\n从十进制数示例出发，我们推广到 \nn\n\n\n\n\n \n\n 位的 \nb\n\n\n\n\n \n\n 进制数 \n(b_{n-1}b_{n-1}...b_1b_0)_{b}\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n \n \n\n\n ，它的值可以定义为：\n\n(b_{n-1}b_{n-2}...b_1b_0)_{b} = \\sum _{i=0} ^{n-1}{b_{i}b^{i}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n \n \n\n \n\n \n\n \n \n \n\n\n \n \n \n\n\n\n \n \n\n \n \n\n\n\n\n对于这样的\nb\n\n\n\n\n \n\n进制的数字（右下角的\nb\n\n\n\n\n \n\n代表这个字符串使用了\nb\n\n\n\n\n \n\n进制），我们不难看出：\n\nb进制数的基数为 \nb\n\n\n\n\n \n\n\nb进制数第 \ni\n\n\n\n\n \n\n 位的位权为 \nb^i\n\n\n\n\n\n \n \n\n\n\n\n补充说明\n在前文的例子中，我们注意到一个字符串使用的进制信息是标注在字符串的右下角的。实际上我们也可以在字符串的末尾加上进制的首字母大写以表明使用的进制，例如：\n\n\n二进制 B(binary)\n\n0101111011B\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n八进制 O(octal)\n\n756547O\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\n十进制 D(decimal)\n\n810975D\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\n十六进制 H(hexadecimal)\n\nADCB1FH\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\n\n \n计算机常用的进制转换\n现代计算机是基于二进制的数制进行工作的，信息在计算机中以二进制字符串的形式进行存储。\n然而使用二进制的表示法比较冗长，这种对机器友好的表示方法人是很难看明白的。而人们熟悉的十进制与二进制之间的转换又比较麻烦，因此我们引入了十六进制数。我们熟悉的十进制数是由数字0~9组成，而十六进制数字则是由数字0~9和字母A~F来表示十六个可能的数值。\n十六进制数是以0x开头，这个x可以是小写也可以是大写。十六进制数字中的字母部分可以全部是大写，也可以全部是小写，甚至大小写混合也是正确的。下面这个例子很好的展示了十六进制数字的多种写法。\n\n在历史上八进制的表示方式也曾广泛应用在12位、24位和36位的机器上（所以很多编程语言也支持八进制表示法），现在八进制的主要应用在处理UTF-8编码上。\n我们发现，计算机领域经常使用的数制有二进制、八进制、十进制、十六进制。既然一个数值可以被表示为多种形式，那么紧接着出现的问题就是，这些不同的表示应该如何互相转换，也就是如何进行进制转换。\n \n十进制\n\\longleftrightarrow\n\n\n\n\n \n\n二进制、八进制、十六进制\n二进制、八进制、十六进制\n\\longrightarrow\n\n\n\n\n \n\n十进制转换\n对于二、八、十六进制向十进制的转换，直接采用定义式即可，\n\n(b_{n-1}b_{n-1}b_1b_0)_{b}= \\sum_{i=0}^{n-1}{b_{i}b^{i}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n\n \n \n\n\n \n \n\n\n \n \n\n \n\n \n\n \n \n \n\n\n \n \n \n\n\n\n \n \n\n \n \n\n\n\n\n实例解析：\n\n二进制数 \n\\longrightarrow\n\n\n\n\n \n\n 十进制数\n\n\n(1100\\ 0101\\ 1111\\ 1101\\ 1111)B =\\\\\n1*2^{19} + 1*2^{18} + 0*2^{17} + 0*2^{16} +\\\\\n0*2^{15} + 1*2^{14} + 0*2^{13} + 1*2^{12} +\\\\\n1*2^{11} + 1*2^{10} + 1*2^{9} + 1*2^{8} +\\\\\n1*2^{7} + 1*2^{6} + 0*2^{5} + 1*2^{4} +\\\\\n1*2^{3} + 1*2^{2} + 1*2^{1} + 1*2^{0} \\\\\n= 810975D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n\n \n \n \n \n\n\n \n \n \n \n\n\n \n \n \n \n\n \n \n \n\n\n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n\n\n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n\n\n \n \n\n \n\n \n \n\n\n \n \n \n\n \n\n \n \n\n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n\n\n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n\n\n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n\n\n \n\n \n \n \n \n \n \n\n \n\n\n\n\n八进制数 \n\\longrightarrow\n\n\n\n\n \n\n 十进制数\n\n\n(305\\ 7737)O = \\\\\n3*8^{6} + 0*8^{5} + 5*8^{4} + \\\\ \n7*8^{3} + 7*8^{2} + 3*8^{1} + 7*8^{0} \\\\ \n= 810975D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n \n \n \n\n \n \n \n\n\n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n\n\n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n\n\n \n\n \n \n \n \n \n \n\n \n\n\n\n\n十六进制数 \n\\longrightarrow\n\n\n\n\n \n\n  十进制数\n\n\n(C5FDF)H = 0xC5FDF = \\\\\nC*16^4 + 5*16^3 + F*16^2 + D*16^1 + F*16^0\\\\ = 810975D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n \n \n \n\n\n\n \n\n \n \n \n \n \n \n\n \n\n\n\n十进制\n\\longrightarrow\n\n\n\n\n \n\n二进制、八进制、十六进制\n十进制向其他进制转换的方法可以利用以下规律进行计算：\n\n\\text{设}x 为一个非负整数，其 b 进制表达为(b_{n-1}b_{n-2}...b_1b_0)_b， 存在以下等式:\\\\\nx\\ mod\\ b = b_0 \\\\\n\\lfloor x/b \\rfloor = (b_{n-1}b_{n-2}...b_1)_b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n设\n \n\n为\n\n\n一\n\n\n个\n\n\n非\n\n\n负\n\n\n整\n\n\n数\n\n\n，\n\n\n其\n\n \n\n进\n\n\n制\n\n\n表\n\n\n达\n\n\n为\n\n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n \n \n\n\n，\n\n\n存\n\n\n在\n\n\n以\n\n\n下\n\n\n等\n\n\n式\n\n \n\n\n \n \n \n \n \n \n\n \n \n\n\n\n \n \n \n \n \n \n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n\n\n\n注：mod为取余操作，\n\\lfloor a \\rfloor\n\n\n\n\n\n\n \n \n \n\n 为对 \na\n\n\n\n\n \n\n 向下取整\n\n相信聪明的你已经发现了，\nx/b\n\n\n\n\n\n\n \n \n \n\n 的余数就是十进制数 \nx\n\n\n\n\n \n\n 的 \nb\n\n\n\n\n \n\n 进制表达的最末一位，\nx/b\n\n\n\n\n\n\n \n \n \n\n 的商就是十进制数 \nx\n\n\n\n\n \n\n 的 \nb\n\n\n\n\n \n\n 进制表达除去最末一位的其余位。利用这个规律，我们可以递归地计算出十进制数的 \nb\n\n\n\n\n \n\n 进制表达。下面给出几个示例\n\n十进制 \n\\longrightarrow\n\n\n\n\n \n\n 二进制\n\n\nstep1:\\ \\lfloor 61/2 \\rfloor=30 \\hspace{1em} 61\\ mod\\ 2 = 1 \\\\\nstep2:\\ \\lfloor 30/2 \\rfloor=15 \\hspace{1em} 30\\ mod\\ 2 = 0 \\\\\nstep3:\\ \\lfloor 15/2 \\rfloor=7 \\hspace{1em} 15\\ mod\\ 2 = 1 \\\\\nstep4:\\ \\lfloor 7/2 \\rfloor=3 \\hspace{1em} 7\\ mod\\ 2 = 1 \\\\\nstep5:\\ \\lfloor 3/2 \\rfloor=1 \\hspace{1em} 3\\ mod\\ 2 = 1 \\\\\nstep6:\\ \\lfloor 1/2 \\rfloor=0 \\hspace{1em}  1\\ mod\\ 2 = 1 \\\\\n\n\\Rightarrow 61D = 111101B\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n\n \n \n\n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n\n \n \n\n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n\n \n \n\n \n \n\n \n \n \n \n \n \n\n \n\n\n\n\n十进制 \n\\longrightarrow\n\n\n\n\n \n\n 八进制\n\n\nstep1:\\ \\lfloor 61/8 \\rfloor=7 \\hspace{1em} 61\\ mod\\ 8 = 5 \\\\\nstep2:\\ \\lfloor 7/8 \\rfloor=0 \\hspace{1em} 7\\ mod\\ 8 = 7 \\\\\n\n\\Rightarrow 61D = 75O\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n \n\n \n \n\n \n \n\n \n \n\n \n\n\n\n\n十进制 \n\\longrightarrow\n\n\n\n\n \n\n 十六进制\n\n\nstep1:\\ \\lfloor 61/16 \\rfloor=3 \\hspace{1em} 61\\ mod\\ 16 = 13 = D \\\\\nstep2:\\ \\lfloor 3/16 \\rfloor=0 \\hspace{1em} 3\\ mod\\ 16 = 3 \\\\\n\n\\Rightarrow 61D = 3DH = 0x3D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n \n\n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n\n \n \n\n \n \n\n\n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n\n \n \n\n \n \n\n\n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n\n\n\n十六进制\n\\longleftrightarrow\n\n\n\n\n \n\n二进制\n\\longleftrightarrow\n\n\n\n\n \n\n八进制\n二进制 \n\\longleftrightarrow\n\n\n\n\n \n\n 十六进制\n二进制与十六进制之间的转换比较简单直接，数字之间的转换可以参考下表。《深入理解计算机》中介绍了一个小技巧，记住十六进制数A\\C\\F所对应的十进制数值，那么B\\D的数值可以由A\\C加一得到，E的数值可以由F减一得到。\n\n十六进制数向二进制数的转换比较简单，通过展开每个十六进制数字，将它转换为上表中对应的二进制格式即可。\n反过来，给出一个二进制数，将它转换为十六进制。首先，我们从右向左，每四位为一组来转换为相应的十六进制数，不过要注意的是，如果总位数不是四的倍数，那么最左边的一组会出现小于四位的情况，这时将前面进行补零，然后将每四位为一组的二进制数进行一一转换，即可得到对应的十六进制数。\n\n二进制 \n\\longleftrightarrow\n\n\n\n\n \n\n 八进制\n二进制与八进制之间的转换和前文类似，数字之间的转换可以参考下表\n\n\nDeciaml 十进制\nOctal 八进制\nBinary 二进制\n\n\n\n\n0\n0\n000\n\n\n1\n1\n001\n\n\n2\n2\n010\n\n\n3\n3\n011\n\n\n4\n4\n100\n\n\n5\n5\n101\n\n\n6\n6\n110\n\n\n7\n7\n111\n\n\n八进制数向二进制数的转换：通过展开每个八进制数字，将它转换为上表中对应的二进制格式即可，举例来说，\n1507O= 001\\ 101\\ 000\\ 111B = 001101000111B = 1101000111B\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n \n \n \n\n\n \n \n \n\n\n \n \n \n\n\n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n\n \n\n 。\n二进制数向八进制数的转换：从右向左，每三位为一组来转换为相应的八进制数，不过要注意的是，如果总位数不是三的倍数，那么最左边的一组会出现小于三位的情况，这时将前面进行补零，然后将每三位为一组的二进制数进行一一转换，即可得到对应的八进制数。举例来说：\n1101000111B=1\\ 101\\ 000\\ 111B = 001\\ 101\\ 000\\ 111B = 1507O\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n\n\n \n \n \n\n\n \n \n \n\n \n \n\n \n \n \n\n\n \n \n \n\n\n \n \n \n\n\n \n \n \n\n \n \n\n \n \n \n \n\n \n\n\n八进制 \n\\longleftrightarrow\n\n\n\n\n \n\n 十六进制\n八进制和十六进制的互相转换，可以将八进制转换成二进制，再将二进制转换成十六进制即可。\n进制转换工具\n除了手工计算以外，你也应该熟悉一些进制转换的工具\n\n\nwindow系统的计算器专门提供了程序员模式，可以快速地在十六进制、十进制、八进制、二进制之间进行数制转换。\n\n\n网上有许多在线的进制转换网站，大家可以自行查找，这里不做赘述\n\n\n你已经是一个成熟的软件工程系学生了，该学会自己造轮子了（x）\n\n\n原码、反码、补码的运算规则\n首先我想把整套关于原码、反码、补码的定义和转换规则准确清晰地写一遍，方便同学们快速开始完成相应的作业和实验。后面会附上拓展阅读部分，探讨一些原理性的内容，也希望大家首先能记住这套规定，再开始进一步的探讨。\n\n本节中对概念的解释基本按照【定义及解释】【形式化书写】【示例】的顺序行文。对于这三个部分，大家可以按需阅读（比如不喜欢形式化语言可以跳过）。“不管黑猫白猫，捉到老鼠就是好猫”，只要你能掌握它们的定义和转换规则就达到了要求。\n\n原码\n原码\n\\longrightarrow\n\n\n\n\n \n\n十进制数值\n在数学上表示有符号整数时，我们使用前导的负号 \n-\n\n\n\n\n \n\n 表示负数；那么用二进制表示整数的最直观想法，就是使用一位来表示正负号，这种表示方法被称作原码。我们人为规定原码的最高位为符号位，正数为0，负数为1，其余n-1位用于表示数值。从原码的定义我们可以发现，原码对二进制数的解释方式使用了符号位的概念，借助这个定义，我们自然地给出从原码求十进制数值的形式化表达：设 \nn\n\n\n\n\n \n\n 位二进制数 \nx_{n-1}x_{n-1}...x_1x_0\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n 使用原码表示一个数 \nX\n\n\n\n\n \n\n，则数值 \nX\n\n\n\n\n \n\n 为：\n\nX=\\left( -1 \\right) ^{x_{n-1}}\\cdot \\left( x_{n-2}\\cdot 2^{n-2}+x_{n-2}\\cdot 2^{n-2}+\\cdots +x_1\\cdot 2^1+x_0\\cdot 2^0 \\right) \n\\\\\n\\,\\, =\\left( -1 \\right) ^{x_{n-1}}\\sum_{i=0}^{n-2}{x_i\\cdot 2^i}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n \n \n\n \n\n \n \n \n\n\n\n \n\n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n \n\n \n \n\n \n\n \n \n\n \n\n \n \n\n \n\n\n\n \n\n \n \n \n \n\n \n\n \n \n \n\n\n\n\n \n\n \n \n \n\n\n \n \n \n\n\n\n \n \n \n\n \n \n\n\n\n\n\n举例而言，一个8位的机器码，则 \n0000\\ 0101B\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n \n\n 和 \n1000\\ 0101B\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n \n\n 的原码分别可以通过如下步骤计算，\n\n(0000\\ 0101) = (-1)^0(1*2^2+1*2^0) = 5 \n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n \n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n\n\n(1000\\ 0101) = (-1)^1(1*2^2+1*2^0) = -5\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n \n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n \n \n \n\n\n原码\n\\longleftarrow\n\n\n\n\n \n\n十进制数值\n反过来，已知十进制数值，求对应的原码，我们设数值为 \nX\n\n\n\n\n \n\n，则其原码 \n[X]_{原}\n\n\n\n\n\n\n \n \n\n \n\n原\n\n\n\n为\n\n[X]_{\\text{原}}=\\begin{cases}\n\t\\,\\,    D2B(X)\\,\\,    \\text{，}0\\leqslant X\\leqslant 2^{n-1}-1\\\\\n\tD2B(2^{n-1}-X)\\text{，}-2^{n-1}+1\\leqslant X\\leqslant 0\\\\\n\\end{cases}\n\n\\\\\n\\\\\n公式中D2B的含义是将十进制数转换为二进制数，是Deciaml\\ to\\ Binary的缩写\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n原\n\n\n \n\n \n\n\n\n \n \n \n \n \n \n\n，\n\n \n \n \n \n\n \n\n \n \n \n\n\n \n \n\n\n \n \n \n \n\n \n\n \n \n \n\n\n \n \n \n\n，\n\n \n\n \n\n \n \n \n\n\n \n \n \n \n \n \n\n\n\n\n\n\n\n公\n\n\n式\n\n\n中\n\n \n \n \n\n的\n\n\n含\n\n\n义\n\n\n是\n\n\n将\n\n\n十\n\n\n进\n\n\n制\n\n\n数\n\n\n转\n\n\n换\n\n\n为\n\n\n二\n\n\n进\n\n\n制\n\n\n数\n\n\n，\n\n\n是\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n的\n\n\n缩\n\n\n写\n\n\n\n\n举例而言，一个8位的机器码，则  \n[5]_原 = D2B(5) = (0000\\ 0101)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n原\n\n\n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n  \n[-5]_{原} = D2B(2^7-(-5)) = D2B(2^7 + 5) = (1000\\ 0101)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n\n原\n\n\n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n\n对于n位原码，最高位为0，其余位全为1时，原码表示的数值取得最大值 \n2^{n-1}-1\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n \n\n ；最高位为1，其余位全为1时，原码表示的数值取得最小值 \n-2^{n-1}+1\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n \n \n\n。因此 \nn\n\n\n\n\n \n\n 位原码所表示的数值范围为 \n[-2^{n-1}+1,2^{n-1}-1]\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n \n\n\n \n \n \n\n。\n反码\n反码\n\\longleftarrow\n\n\n\n\n \n\n原码\n反码，英语里叫ones’ complement（对1求补），这里的1，本质上是一个有限位计数系统里所能表示出的最大值，在8位二进制里就是\n11111111\n\n\n\n\n \n \n \n \n \n \n \n \n\n，在1位十进制里就是9，在3位十六进制里就是\nFFF\n\n\n\n\n \n \n \n\n。求反又被称为对一求补，用最大数减去一个数就能得到它的反。\n既然反码的本质是对1求补，那为什么我们叫它反码呢？这是因为在二进制里\n11111111\n\n\n\n\n \n \n \n \n \n \n \n \n\n减去任何数结果都是把这个数按位取反，0变1，1变零。因此用原码求反码的方法是，正数不变，负数保留符号位1不变，剩下位按位取反。\n形式化地说，设\nn\n\n\n\n\n \n\n 位二进制数 \nx_{n-1}x_{n-1}...x_1x_0\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n 使用原码表示一个数 \nX\n\n\n\n\n \n\n，则数值 \nX\n\n\n\n\n \n\n 的反码为：\n\n[X]_{\\text{反}}=\\begin{cases}\n\tx_{n-1}x_{n-1}\\cdots x_1x_0,\\ \\ \\ \\ x_{n-1} = 0 \\\\\n\tx_{n-1}\\left( 1-x_{n-1} \\right) \\cdots \\left( 1-x_1 \\right) \\left( 1-x_0 \\right) ,    \\ \\ \\ \\ x_{n-1}=1 \\\\\n\\end{cases}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n反\n\n\n \n\n \n\n\n\n \n\n \n \n \n\n\n \n\n \n \n \n\n\n \n\n \n \n\n\n \n \n\n \n\n \n\n \n \n \n\n\n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n \n \n\n \n\n\n \n \n \n\n \n \n\n \n\n \n\n \n\n \n \n \n\n\n \n \n\n\n\n\n\n\n举例而言，一个8位的机器码AAAA，给出原码 \n(0101\\ 0011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 和  \n(1000\\ 0001)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 可以通过上述公式求出其反码：\n\n[0101\\ 0011]原= [0101\\ 0011]反\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n反\n\n\n 【最高位为0】\n\n[1000\\ 0001]原= [1111\\ 1110]反\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n反\n\n\n 【最高位为1】\n反码\n\\longrightarrow\n\n\n\n\n \n\n原码\n反过来，通过反码求出其原码，只需要对前面的操作进行逆运算即可。正数不变，负数保留符号位不变，其余位取反。\n举例而言，一个8位的机器码，给出反码 \n(0001\\ 1011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 和  \n(1001\\ 1011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 可以通过上述公式求出其原码：\n【最高位为0】\t\n[0001\\ 1011]反= [0001\\ 1011]原\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n反\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n\n\n【最高位为1】\t\n[1001\\ 1011]反= [1110\\ 0100]原\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n反\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n\n\n对于n位的反码，最高位为0，其余位全为1时，原码表示的数值取得最大值 \n2^{n-1}-1\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n \n\n ；最高位为1，其余位全为0时，反码表示的数值取得最小值 \n-2^{n-1}+1\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n \n \n\n。因此 \nn\n\n\n\n\n \n\n 位反码所表示的数值范围为 \n[-2^{n-1}+1,2^{n-1}-1]\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n \n\n\n \n \n \n\n。\n补码\n补码\n\\longleftarrow\n\n\n\n\n \n\n原码\n补码，英语里叫做two’s complement（对2求补），这个2指的是计数系统的容量（模），就是计数系统所能表示的状态数，所以补码是在模意义上定义的。对1位二进制数来说只有0和1两种状态，所以模是\n10B\n\n\n\n\n\n\n \n \n \n\n。对7位二进制数来说就是\n1000\\ 0000B\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n \n\n，用模减去一个数（无符号部分）就能得到这个数的。比如\n1000\\ 0000B－101\\ 0010B=010\\ 1110B\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n \n\n－\n\n\n \n \n \n\n\n \n \n \n \n\n \n \n\n \n \n \n\n\n \n \n \n \n\n \n\n，事实上因为\n1000\\ 0000B=111\\ 1111B+1B\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n \n \n\n \n \n \n\n\n \n \n \n \n\n \n \n \n \n\n，稍加改变就成了\n(1111111B－1010010B)+1B\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n \n \n\n \n\n－\n\n\n \n \n \n \n \n \n \n\n \n \n \n \n \n\n，括号里面的式子和前文提到的反码取反操作相同，所以求补又可以表述为先求反再加1。因此：已知原码求补码的方法就是正数依旧不变，负数保留符号位不变，其余部分先求反码再加上1。\n形式化地说，设 \nn\n\n\n\n\n \n\n 位二进制数 \nx_{n-1}x_{n-1}...x_1x_0\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n使用原码表示一个数 \nX\n\n\n\n\n \n\n，则数值 \nX\n\n\n\n\n \n\n 的补码为：\n\n[X]_{\\text{补}}=\\begin{cases}\n\tx_{n-1}x_{n-1}\\cdots x_1x_0,\\ \\ \\ \\ x_{n-1}=0 \\\\\n\tx_{n-1}\\left( 1-x_{n-1} \\right) \\cdots \\left( 1-x_1 \\right) \\left( 1-x_0 \\right) +1,    \\ \\ \\ \\ x_{n-1}=1\\\\\n\\end{cases}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n补\n\n\n \n\n \n\n\n\n \n\n \n \n \n\n\n \n\n \n \n \n\n\n \n\n \n \n\n\n \n \n\n \n\n \n\n \n \n \n\n\n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n \n \n\n \n\n\n \n \n \n\n \n \n\n \n\n \n \n \n\n \n\n \n \n \n\n\n \n \n\n\n\n\n\n\n举例而言，一个8位的机器码，给出原码 \n(0001\\ 1011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 和  \n(1001\\ 1011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 可以通过上述公式求出其补码：\n\n[0001\\ 1011]原= [0001\\ 1011]补)\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n补\n\n \n\n 【最高位为0】\n\n[1001\\ 1011]原= ([1110\\ 0100]+1)补 = [1110\\ 0101]补 \n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n \n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n \n \n \n\n补\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n补\n\n\n 【最高位为1】\n补码\n\\longrightarrow\n\n\n\n\n \n\n原码\n反过来，已知一个数值X的补码想求对应原码，只需要对前面的操作进行逆运算即可。正数不变，负数的符号位不变，其余位减一再取反。\n举例而言，\t一个8位的机器码，给出反码 \n(0001\\ 1011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 和  \n(1001\\ 1011)\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n 可以通过上述公式求出其原码：\n【最高位为0】\t\n[0001\\ 1011]补= [0001\\ 1011]原\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n补\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n\n\n【最高位为1】\t\n[1001\\ 1011]补= [1001\\ 1011]反-1反 = [1001\\ 1010]反 = [1110\\ 0101]原码\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n补\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n反\n\n \n \n\n反\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n反\n\n \n \n\n \n \n \n \n\n\n \n \n \n \n\n \n\n原\n\n\n码\n\n\n\n对于n位的补码，最高位为0，其余位全为1时，补码表示的数值取得最大值 \n2^{n-1}-1\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n \n\n ；最高位为1，其余位全为0时，补码表示的数值取得最小值 \n-2^{n-1}\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n\n。因此 \nn\n\n\n\n\n \n\n 位补码所表示的数值范围为 \n[-2^{n-1},2^{n-1}-1]\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n\n \n \n \n\n。\n拓展阅读\n补码是怎么来的？\n在上一节中我们介绍了原码、反码、补码的定义和转换规则。不难发现，原码的表示方式最容易被人理解，那为什么还会出现反码和补码呢？这个问题实际上和计算机硬件的设计有关。计算机实现加法运算是很容易的，但直接作减法则比较复杂，需要处理借位等情况，内部逻辑组件会增多，效率也就会降低。\n所以我们需要一种编码方式，它支持将减法转换成加法，即\nA - B = A + (-B)\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\n原码\n先来看看原码，原码的优点是编码格式对人很友好，类似十进制中的正负号，原码用最高位0和1分别代码正负数，很直观的表示了正负数。但是原码也有一个很大的缺点，就是无法将减法转换成加法运算，如：\n例： \n4-2\n\n\n\n\n\n\n \n \n \n\n【使用原码】\n\n4D - 2D = 4D + (-2D)= 0100B + 1010B = 1110B= -6H\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n \n \n \n\n\n上面例子计算\n4-2\n\n\n\n\n\n\n \n \n \n\n，将\n4-2\n\n\n\n\n\n\n \n \n \n\n转换成\n4+(-2)\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n并用原码计算，得出的结果错误，原码虽然很直观转换了十进制数，但是并不支持将减法转换为加法。\n反码\n于是人们考虑寻找一种支持将减法转换为加法二进制编码方式，最初找到的解决方案是反码。反码的负数编码格式不像原码那样直观，但是却可以将减法转换成加法了，反码减法规则为：A - B = A + （-B），如果最高位发生了溢位，则需要在最低位加上1，如下面两个例子：\n例： \n4-2\n\n\n\n\n\n\n \n \n \n\n【使用反码】\n\n4D - 2D = 4D + (-2D)= 0100B + 1101B = 0010B= 2D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n \n \n\n\n例： \n2-2\n\n\n\n\n\n \n \n \n\n【使用反码】\n\n2D-2D=2D+(-2D)=0010B+1101B=1111B=0D\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n \n \n\n\n运用反码减法规则，得到的上面两个例子的减法结果是正确的，所以计算机是可以使用反码存储和计算的，早期的计算机如CDC 6000、LINC、PDP-1等都是使用反码的，但是反码也有两个缺点：1）0有两种编码，+0 （0000）和 -0 （1111），在判断0时，需要分别判断0000和1111；2）反码减法的算法规则比较复杂，需要增加计算机内部逻辑组件额外判断溢位，会影响计算效率。\n补码\n于是人们又对反码进行了改进，最后发现在模系统下定义的补码可以解决了上面反码的两个缺点。补码的减法规则比较简单，按照最简单的转换公式\nA-B = A + (-B)\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n，当减去一个数时直接转换成加上被减数的负数即可，不用像反码那样额外处理溢位，如下面两个例子：\n例： \n4-2\n\n\n\n\n\n\n \n \n \n\n【使用补码】\n\n4D - 2D = 4D + (-2D)= 0100B + 1110B = 0010B= 2D\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n \n \n\n\n例： \n2-2\n\n\n\n\n\n \n \n \n\n【使用补码】\n\n2D-2D=2D+(-2D)=0010B+1110B=0000B=0D\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n \n \n\n\n使用了补码的加法，上面两个例子得出的结果都是正确的，相对于反码，补码加法更简单，直接丢弃溢位，不需要针对溢位单独处理，所以用补码做运算效率高。因此补码是现代计算机使用的编码格式。\n\n那么为什么补码能解决另外两种编码的问题呢？感兴趣的同学可以阅读参考文章 [3] 中的3.2节 模N加减法\n\nTricks\n下面介绍一些原码、补码、反码相关的小技巧，了解这些技巧后，不同机器码之间的转换图可以更新为如下方式：\n\n\n\n反码和补码之间的转换\n对于非负数，反码和补码是一致的，无需转换\n对于负数，前文已经提到过，补码=原码保留符号位，其余取反，再加一，又有反码=原码保留符号位，其余取反。那么我们发现，反码和补码之间其实只相差了1。也就是说：补码等于反码加一。\n\n\n补码的补码是原码\n让我们回顾补码的定义——two’s complement（对2求补），这个2是计数系统的模。假设一个计数系统的模为N，在这个计数系统下，A的补码为(N-A)。那么A补码的补码就是N-(N-A)，可以发现，A补码的补码就是A本身。所以对于负数，从补码求原码不仅可以通过逆运算减一取反，还可以利用模运算系统的性质，再次取反加一。\n\n\n补码\n\\longrightarrow\n\n\n\n\n \n\n十进制\n不知道你有没有注意到，本文一直在强调一个概念——解释。事实上，对于原码、反码、补码而言，从二进制翻译到十进制的过程，其实都可以看作是不同的解释方式，它们对二进制字符串赋予了不同的位权，进而产生了不同的编码效果。\n在CSAPP一书中给出了补码的位权解释方式，设补码为\nn\n\n\n\n\n \n\n 位二进制数 \nx_{n-1}x_{n-1}...x_1x_0\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n\n 的二进制数，形式化地说，其对应的十进制数值 \nX\n\n\n\n\n \n\n 为\n\nX = x_{n-1}(-2^{n-1})+x_{n-2}2^{n-2}+x_{n-3}2^{n-3}+\\cdots +x_{1}2^{1}+x_{0}2^{0}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n\n \n \n \n\n\n \n \n\n \n\n \n \n \n\n\n \n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n \n \n \n\n \n \n\n\n \n \n\n \n\n \n \n\n\n \n \n\n\n\n可以看到，补码的最高位的位权是\n-2^{n-1}\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n\n\n 而不是 \n2^{n-1}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n（这样的位权解释方式恰好符合前文提到的对2求补模运算，同学们可以自行验证一下）。使用这个公式，我们可以快速地将补码转换为十进制数。\n\n\n补码的符号扩展\n思考这样一个问题，现在有一个16位的补码\n1000\\ 0001\\ 0000\\ 1011\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n\n \n \n \n \n\n\n \n \n \n \n\n\n，要想得到同样数值的32位补码应该怎么办？你或许想把这个16位的补码先转换为十进制数值再将这个数值转换为32位的补码。但事实上，这样的转换有一个专门的名称——符号扩展。\n这里我只简单介绍结论：补码扩展过程中，补码的符号正数前面补0，负数前面补1，也就是只需要补上符号位的数即可。\n例如四位补码扩展成八位，正数\n0011\n\n\n\n\n\n \n \n \n \n\n，负数\n1101\n\n\n\n\n\n \n \n \n \n\n，经过符号扩展的结果是，正数\n0000\\ 0011\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n\n，负数\n1111\\ 1101\n\n\n\n\n\n \n \n \n \n\n \n \n \n \n\n\n\n\n具体的直觉观察过程和数学推导步骤有兴趣的同学可以自行查看参考内容[1] CSAPP第二章 信息的表示和处理P54-55页。\n\n\n\n数制部分的内容就介绍到这里，祝各位同学在计算机硬件基础里玩的开心 :-)\n\nReference:\n[1]《深入理解计算机系统》（CSAPP）——第二章 信息的表示和处理\n[2] CSAPP-深入理解计算机系统】2-1.信息的存储(上) -B站 https://www.bilibili.com/video/BV1tV411U7N3?share_source=copy_web&amp;vd_source=64521a646fa1bf3b43544380867c980b\n[3] 原码、反码、补码的产生、应用以及优缺点有哪些？ - 祥先生的回答 - 知乎 https://www.zhihu.com/question/20159860/answer/713291288\n\n","thumbnail":"https://oss.horik.cn/blog/header-%E6%95%B0%E5%88%B6%E5%9F%BA%E7%A1%80.jpg","plink":"http://blog.horik.cn/2022/09/07/「计算机组成原理」数制基础/"},{"title":"「系统编程」常用Linux命令","date":"2022-09-04T01:10:12.000Z","date_formatted":{"ll":"Sep 4, 2022","L":"09/04/2022","MM-DD":"09-04"},"updated":"2022-10-25T22:00:24.417Z","content":"这是一篇低创文章，主要是笔者在BUAA学习《系统编程》时的一些笔（zhai）记(chao)内容，大概率是写完就吃灰，或许等到期末或者以后记忆衰退了会掸去灰看看。\n在本文你可以了解到\n\n\nLinux man手册基础阅读方法\n\n\nLinux常用命令及其常用参数的使用示例\n\n\n本文不会谈论\n\n\n高深的Linux命令使用技巧（喂，都说了这是一篇低创文章了，别期待太多捏）\n\n\n完整的Linux命令参数介绍（因为我也看不懂）\n\n\n特别贴合实际应用场景的使用范例（我也没咋用过，想不出来）\n\n\n\nWARNING\n\n笔者使用的是Unbuntu 20.04系统，由于安装时选择了中文系统，所以文中示例会有中英文夹杂的情况\n鉴于本文是男生自用99新笔记，内容会有很强个人性质，先提前叠个甲\n\n\n如果到这里你还有兴趣往下翻翻，那我们就一起开始Linux世界的&quot;Hello World&quot;吧\n\nMan手册基本阅读方法\n让我们从一个故事说起\n\nRead the F**king Manual（RTFM）\n\n上帝用一天时间创造了Linux和系统命令，交付给人类使用还没几天，人类就给上帝发牢骚：“Linux好用是好用，但命令也太多了，每个命令的参数也多如牛毛，用的时候老是忘，忒不方便”，于是上帝又花了两天写出了指令Manual，告诉人类：“遇到不会的就来查Manual，知识都在里面了”。人类开始读Manual，熬了一宿，发现这玩意儿就不是人读的 : ( ，于是上帝又花了三天时间教会了人类怎么阅读Manual，就这样，人类终于能愉快地使用Linux系统了。\n这个故事的本意并不是宣扬Manual有多么强大，事实上它还是很难读（互联网上仍然流传着古老的一句国骂——Read the F**king Manual），我想夹带的私货是一个软件交付时精力耗费的大小顺序：推广维护 &gt;&gt; 写文档 &gt;&gt; 开发软件，这一不等式的约束是如此稳固，以至于伟大的上帝也逃不开，所以一定不要当乙方（悲）\nman的自述\n言归正传，那么伟大的Manual应该怎么读呢？让我们看看man对自己的介绍\n# 命令行输入man man\n$ man man\nMAN(1)                                                                               手册分页显示工具                                                                              MAN(1)\n\n名称\n       man - 系统参考手册的接口\n\n概述\n       man [man 选项] [[章节] 页 ...] ...\n       man -k [apropos 选项] 正则表达式 ...\n       man -K [man 选项] [章节] 关键词 ...\n       man -f [whatis 选项] 页 ...\n       man -l [man 选项] 文件 ...\n       man -w|-W [man 选项] page ...\n\n描述\n       man  是系统的手册分页程序。指定给 man 的 页 选项通常是程序、工具或函数名。程序将显示每一个找到的相关 手册页。如果指定了 章节，man 将只在手册的指定 章节 搜索。默认将按预定的顺序查\n       找所有可用的 章节（参见 默认值 一节），并只显示找到的第一个 页，即使多个 章节 中都有这个 页面。\n\n       下表显示了手册的 章节 号及其包含的手册页类型。\n\n       1   可执行程序或 shell 命令\n       2   系统调用(内核提供的函数)\n       3   库调用(程序库中的函数)\n       4   特殊文件(通常位于 &#x2F;dev)\n       5   文件格式和规范，如  &#x2F;etc&#x2F;passwd\n       6   游戏\n       7   杂项（包括宏包和规范）， 如 man(7)，groff(7), man-pages(7)\n       8   系统管理命令(通常只针对 root 用户)\n       9   内核例程 [非标准\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;后续省略&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nman是一个系统参考手册的入口…啊再写下去就有水字数之嫌了，我不想做一个PPT内嵌的语音助手，请自行查看man的自述。\n总而言之，man命令是一个帮我们从冗长的参考手册中找到想要的内容的工具，你可以把它看成字典的目录。但它和字典目录的用法不同，下面是它的命令用法。\n# man常用命令格式\nman [section number] [-k] command\n呃，你貌似看不太懂，那就来补个课吧（其实看不懂的人就是我，乐）\nThe Missing Semester of Computer Science ---- Linux 命令基础\nLinux命令格式\nlinux命令一般长这个样子\ncommand [option] [arguments]\n偷用PPT上的一张图解释如下，前人之述备矣，我也不多费口舌了。\n\n参数Arguments的运用\n参数分为可选项参数和命令对象参数。两者的区别在于可选项参数是写命令的人预留给使用者的接口，用来调整命令内部的各种参数或配置的，而命令对象参数往往是Linux系统中的一些实体，是命令最终作用的对象，比如文件名、用户名、组。下面依旧是当一下PPT的搬运工：\n\n可选项参数\n\n短格式可选项，如：-f 带参数的短格式可选项，如：-f512 或-f 512\n长格式可选项，如：–filesize\n带参数的长格式可选项，如：–filesize=512\n\n\n命令对象参数\n\n文件名\n用户名、组名\n…\n\n\n\n\n命令格式的一些补充（感觉这个格式和BNF文法有关联，但没细究过）：\n...：可变参数，参数可以写n多个\n|：或，左右两侧的内容选一个就行\n[ab1A-F]：匹配任何一个例举在集合中的字符\n?：匹配任何一个字符\n*：匹配零个或多个字符\n\n其他帮助性的命令\n\n\nInfo\n\ninfo command\n\n  $ info man\n\n\n–help\n\ncommand --help\ncommand -h\n\n  $grep --help\n\n\n–help, man, info的区别\n直接搬运PPT讲解如下：\n\n\n–help: 是一个工具选项,可以用来显示一些工具的信息。这些帮助信息是程序的作者加上去的，也就是说，这些信息是程序内部的。一般比man出来的要简单。\n\n\nman : （manual）可以显示系统手册页中的内容，这些内容大多数都是对命令的解释信息。这些信息是操作系统文档里面的。如果没有文档，是不会显示这些帮助信息的。一般比help出来的要详细。\n(1) Space 键可以显示下一屏的文本信息；(2) q 键是退出。\n\n\ninfo: 是一个基于菜单的超文本系统，是由GNU项目开发并由Linux发布。 info 工具包括一些关于Linux Shell 工具，GNU项目开发程序说明文档。\n(1) ？ 键可以列出info窗口中的相关命令；(2) Space 键可以进行滚动浏览\n\n\n当然，以上的介绍肯定不足以覆盖你在阅读Manual时遇到的所有情况，不过，前面的区域，以后再来探索吧~\n\nLinux常用命令\n\n无他，唯手熟耳\n\n强烈推荐Linux命令搜索引擎，一个优质的中文Linux命令手册，它在说人话，我哭死。\n下面的内容主要是对PPT的整理，部分有所补充，写道一半发现了前面推荐的引擎，权做个mini版内容吧，期末复习的时候也许派的上用场。如果您想看完整用法、参数列表、更多例子的请移步上面推荐的搜索引擎。\n目录操作指令\nls\n# 列出所有文件\nls –a \n\n# 列出所有的目录\nls –d \n\n# 列出文件的详细信息\nls –l \t\ncd\n# 进入&#x2F;usr&#x2F;bin目录。\ncd &#x2F;usr&#x2F;bin\n\n# 进入用户的home directory。\ncd ~ \n\n# 返回到用户主目录\ncd \n\n# 表示进入上次更改目录之前的目录\ncd - \nmkdir、rmdir\n# 创建目录\nmkdir directory-name\n\n# 删除目录 使用rmdir时，要确保目录内已无任何文件，否则命令不成功\nrmdir directory-name\n\n# 递归删除目录，如果子目录删除后若其父目录为空，则将一同删除\nrmdir -p directory-name&#x2F;sub-dir-name\npwd  显示当前工作目录\n# 语法\npwd\n\n文件操作指令\ncat 显示文本文件内容\n# 语法\ncat filename...\n\n# 默认输出到屏幕\ncat file1 file2\n\n# 重定向输出到文件\ncat file1 file2 &gt; file3\ncp 拷贝文件\n#  语法 （在使用cp时一定要有目的地才行）\ncp filename target-place\n\n# 在cp中也可以使用通配符，像*、?\ncp &#x2F;root&#x2F;* &#x2F;temp\nmv 文件更名或搬移\n# 语法\nmv filename target-place(new-filename)\n\n# 把现在所在的目录中的netscape文件移到&#x2F;usr内\nmv netscape &#x2F;usr\n\n# 把现在所在的目录中的netscape文件重命名为nets\nmv netscape nets\nrm 删除文件\n# 语法\nrm filename\n\n# 删除本目录下file文件\nrm file1\ncp mv rm 的几个选项\n-f 表示强制执行，如果目标文件存在则进行覆盖或者\n不提示进行删除\n-i 交互式的执行命令，上述情况下，提示用户。\n-r 递归删除、拷贝。 mv命令没有该选项。\nfind 寻找文件\n# 语法 (将文件系统内符合条件的文件列出来。用户可以指定文件名称、类别、时间、大小、权限等等)\nfind dir-name options\n\n# 列举当前目录及其子目录下所有扩展文件名是c的文件\nfind . -name &quot;*.c&quot;\n\n# 将匹配文件输出到标准输出\nfind . -print -name &quot;.sy&quot;\n\n# 对匹配的文件执行该选项所给出的命令，命令的形式为&#39;command&#39; &#123;&#125; \\;\nfind . -name &quot;*.c&quot; -exec ls –l &#123;&#125; \\;\ngrep 在文件中查找字符串\n# 语法\ngrep str filename\n\n# 在 file1文件中找寻tigger字符串\ngrep tigger file1\n\n# 在 file1文件中找寻 big tigger字符串\ngrep &quot;big tigger&quot; file1\n\n# 查找不包含字符串的行\ngrep -v printf file1\n\n# 将查找结果的行序号显示出来\ngrep -v -n printf file1\n文件备份和压缩命令\n首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。\n为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。\ntar\n# 对文件目录进行打包备份 语法\ntar [选项...] [FILE]...\n\n# 参数-f是必须的\n-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。\n\n# 示例\n# 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。\ntar -cf all.tar *.jpg\n# 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。\ntar -rf all.tar *.gif\n# 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。\ntar -uf all.tar logo.gif\n# 这条命令是列出all.tar包中所有文件，-t是列出文件的意思\ntar -tf all.tar\ntar -cf archive.tar foo bar  # 从文件 foo 和 bar 创建归档文件 archive.tar。\ntar -tvf archive.tar         # 详细列举归档文件 archive.tar 中的所有文件。\ntar -xf archive.tar          # 展开归档文件 archive.tar 中的所有文件。\n\n# 将 &#x2F;home&#x2F;vivek&#x2F;bin&#x2F; 目录打包，并使用 gzip 算法压缩。保存为 &#x2F;tmp&#x2F;bin-backup.tar.gz 文件。\ntar -zcvf &#x2F;tmp&#x2F;bin-backup.tar.gz &#x2F;home&#x2F;vivek&#x2F;bin&#x2F; \n其实最简单的使用 tar 就只要记忆底下的方式即可：\n压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称\n查　询：tar -jtv -f filename.tar.bz2\n解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录\n这里使用的压缩方式是bz2，更多的压缩算法使用方式详见https://wangchujiang.com/linux-command/c/tar.html\ngzip\n# 压缩文件 语法\n# 压缩以后原文件会消失\ngzip 选项 文件目录列表\n\n# 压缩文件testgzip并且打印显示每个文件的名子和压缩率\ngzip –v &#x2F;home&#x2F;horik&#x2F;testgzip\n\n# 解压文件\ngzip -d testgzip.gz\n\n# 一条命令压缩多个文件，压缩之后，是各自分开的\ngzip file1.txt file2.txt\n\n# 压缩过程中，保留原文件\ngzip -k file1.txt\n\n# 详细显示压缩的文件的信息，并不解压\ngzip -l testgzip.gz\n\n关机和系统管理命令\nshutdown 系统关机\n# 语法\nshutdown(选项)(参数)\n\n# 选项\n-c：当执行“shutdown -h 11:50”指令时，只要按+键就可以中断关机的指令；\n-f：重新启动时不执行fsck；\n-F：重新启动时执行fsck；\n-h：将系统关机；\n-k：只是送出信息给所有用户，但不会实际关机；\n-n：不调用init程序进行关机，而由shutdown自己进行；\n-r：shutdown之后重新启动；\n-t&lt;秒数&gt;：送出警告信息和删除信息之间要延迟多少秒。\n\n# 参数\n[时间]：设置多久时间后执行shutdown指令；\n[警告信息]：要传送给所有登入用户的信息。\n\n# 示例\nshutdown -h now # 指定现在立即关机\nshutdown +5 &quot;System will shutdown after 5 minutes&quot; # 指定5分钟后关机，同时送出警告信息给登入用户\nshutdown –h 20:25 # 系统会在今天20:25关机\nshutdown –r now # 系统立马重启\nshutdown –r +10 # 系统十分钟后重启\ndate 显示系统的日期和时间\nhorik@Horik:~&#x2F;playground$ date\n2022年 09月 03日 星期六 01:31:23 CST\nwho  查看当前在线的用户情况\n\n当用户执行 who am i 时，只显示运行该命令的用户的信息。\n\n# 当没有给出非选项参数时，按以下字段顺序为每个当前用户打印信息：登录用户名称，终端信息，登录时间，远程主机或X display。\n[root@localhost ~]# who\nroot     pts&#x2F;0        2013-08-19 15:04 (192.168.0.134)\nroot     pts&#x2F;1        2013-12-20 10:37 (180.111.155.40)\n\n# 列出所有已登录的用户的名称和数量。\n[root@localhost ~]# who -q\nroot root\n# users&#x3D;2\n\n# 打印列标题行\n[root@localhost ~]# who -H\nNAME     LINE         time             COMMENT\nroot     pts&#x2F;0        2013-08-19 15:04 (192.168.0.134)\nroot     pts&#x2F;1        2013-12-20 10:37 (180.111.155.40)\n\n[root@localhost ~]# who -w\nroot     + pts&#x2F;0        2013-08-19 15:04 (192.168.0.134)\nroot     + pts&#x2F;1        2013-12-20 10:37 (180.111.155.40)\n\n用户管理命令\nuseradd 建立用户帐号\n# 建立一个新用户账户，并设置ID：\n# 需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、mail这样的系统账号。\nuseradd horik -u 544\n\n# 新建用户加入组：\nuseradd –g sales jack –G company,employees    # -g：加入主要组、-G：加入次要组\ngroupadd 创建用户组\ngroupadd student &#x2F;&#x2F;创建一个student组\npasswd 修改密码\n如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建。\n普通用户如果想更改自己的密码，直接运行passwd即可\npasswd username\t&#x2F;&#x2F; 设置user的密码\nLinux用户权限说明\n# 查看当前目录（包含隐藏文件）的长格式。\nls -la\n  -rw-r--r--   1 user  staff   651 Oct 12 12:53 .gitmodules\n\n# 第1位如果是d则代表目录，是-则代表普通文件。\n# 第2到4位代表当前用户的权限。\n# 第5到7位代表组用户的权限。\n# 第8到10位代表其他用户的权限。\nchmod 变更文件或目录的权限\n\n\n通过符号组合的方式更改目标文件或目录的权限。\n  chmod [OPTION]... MODE[,MODE]... FILE...\n\n\n通过八进制数的方式更改目标文件或目录的权限。\n  chmod [OPTION]... OCTAL-MODE FILE...\n\n\n通过参考文件的权限来更改目标文件或目录的权限。\n  chmod [OPTION]... --reference&#x3D;RFILE FILE...\n\n\n\n参考man chmod文档的DESCRIPTION段落得知：\n\nu符号代表当前用户。\ng符号代表和当前用户在同一个组的用户，以下简称组用户。\no符号代表其他用户。\na符号代表所有用户。\nr符号代表读权限以及八进制数4。\nw符号代表写权限以及八进制数2。\nx符号代表执行权限以及八进制数1。\nX符号代表如果目标文件是可执行文件或目录，可给其设置可执行权限。\ns符号代表设置权限suid和sgid，使用权限组合u+s设定文件的用户的ID位，g+s设置组用户ID位。\nt符号代表只有目录或文件的所有者才可以删除目录下的文件。\n+符号代表添加目标用户相应的权限。\n-符号代表删除目标用户相应的权限。\n=符号代表添加目标用户相应的权限，删除未提到的权限。\n\n\n示例如下：\n# 添加组用户的写权限。\nchmod g+w .&#x2F;test.log\n# 删除其他用户的所有权限。\nchmod o&#x3D; .&#x2F;test.log\n# 使得所有用户都没有写权限。\nchmod a-w .&#x2F;test.log\n# 当前用户具有所有权限，组用户有读写权限，其他用户只有读权限。\nchmod u&#x3D;rwx, g&#x3D;rw, o&#x3D;r .&#x2F;test.log\n# 等价的八进制数表示：\nchmod 764 .&#x2F;test.log\t# 使用此方式设置时，八进制数字的设置对应顺序为ugo，和file的权限信息显示顺序一致\n# 将目录以及目录下的文件都设置为所有用户拥有读写权限。\n# 注意，使用&#39;-R&#39;选项一定要保留当前用户的执行和读取权限，否则会报错！\nchmod -R a&#x3D;rw .&#x2F;testdir&#x2F;\n# 根据其他文件的权限设置文件权限。\nchmod --reference&#x3D;.&#x2F;1.log  .&#x2F;test.log\nchown 变更文件或目录的拥有者或所属群组\nchown命令 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组。用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。\n只有文件主和超级用户才可以便用该命令。\n# 将目录&#96;&#x2F;home&#x2F;horik&#96;及其下面的所有文件、子目录的文件主改成 horik：\nchown -R horik &#x2F;home&#x2F;horik\n\n文件阅读命令\nmore 显示文件内容，每次显示一屏\nmore命令 是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。more名单中内置了若干快捷键，常用的有H（获得帮助信息），Enter（向下翻滚一行），空格（向下滚动一屏），Q（退出命令）。\n该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：–More–（XX%）可以用下列不同的方法对提示做出回答：\n\n按 Space 键：显示文本的下一屏内容。\n按 Enter 键：只显示文本的下一行内容。\n按斜线符/：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。\n按``H`键：显示帮助屏，该屏上有相关的帮助信息。\n按B键：显示上一屏内容。\n按``Q`键：退出more命令。\n\n# 语法\nmore arguments... file\n\n# 参数\n-&lt;数字&gt;：指定每屏显示的行数；\n-d：显示“[press space to continue,&#39;q&#39; to quit.]”和“[Press &#39;h&#39; for instructions]”；\n-c：不进行滚屏操作。每次翻页都刷新屏幕\n-s：将多个空行压缩成一行显示；\n-u：禁止下划线；\n+&lt;数字&gt;：从指定数字的行开始显示。\n\n# 示例\n# 显示文件file的内容，但在显示之前先清屏，并且在屏幕的最下方显示完成的百分比。\nmore -dc file\n# 显示文件file的内容，每10行显示一次，而且在显示之前先清屏。\nmore -c -10 file\nless 分屏上下翻页浏览文件内容\nless命令 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键\n# 语法\nless filename\n\n# 示例\nless &#x2F;var&#x2F;log&#x2F;shadowsocks.log\ncat ,more, less 命令差异\n这三者命令均具有查看文件内容之功能。\n\n\ncat命令一次显示所有文件内容，而后两者可与用户交换以方便用户查看。\n\n\ncat命令还具有合并文件之功能。\n\n\nless允许用户后翻查看已经阅读过的内容；less并未在一开始就读入文件所有内容，因此其在查看文件时比vi速度快。\n\n\nless比more支持更多的控制命令\n\n\n\n磁盘管理命令\ndf 显示磁盘的使用\ndf命令 用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n实例\n查看系统磁盘设备，默认是KB为单位：\nhorik@Horik:~$ df\n文件系统            1K-块      已用      可用 已用% 挂载点\nnone              3917044         4   3917040    1% &#x2F;mnt&#x2F;wsl\ndrivers         480140612 363464016 116676596   76% &#x2F;usr&#x2F;lib&#x2F;wsl&#x2F;drivers\nnone              3917044         0   3917044    0% &#x2F;usr&#x2F;lib&#x2F;wsl&#x2F;lib\n&#x2F;dev&#x2F;sdc       1055762868   7060764 994998632    1% &#x2F;\nnone              3917044        88   3916956    1% &#x2F;mnt&#x2F;wslg\nrootfs            3913724      1876   3911848    1% &#x2F;init\nnone              3917044         4   3917040    1% &#x2F;run\nnone              3917044         0   3917044    0% &#x2F;run&#x2F;lock\nnone              3917044         0   3917044    0% &#x2F;run&#x2F;shm\nnone              3917044         0   3917044    0% &#x2F;run&#x2F;user\ntmpfs             3917044         0   3917044    0% &#x2F;sys&#x2F;fs&#x2F;cgroup\nnone              3917044        88   3916956    1% &#x2F;mnt&#x2F;wslg&#x2F;versions.txt\nnone              3917044        88   3916956    1% &#x2F;mnt&#x2F;wslg&#x2F;doc\ndrvfs           480140612 363464016 116676596   76% &#x2F;mnt&#x2F;c\ndrvfs            18350076  12716188   5633888   70% &#x2F;mnt&#x2F;d\ndrvfs           488296444  24253600 464042844    5% &#x2F;mnt&#x2F;e\ndrvfs           488447996  93731416 394716580   20% &#x2F;mnt&#x2F;f\n使用-h选项以KB以上的单位来显示，可读性高：\n# -h, --human-readable                   以K，M，G为单位，提高信息的可读性。\nhorik@Horik:~$ df -h\n文件系统        容量  已用  可用 已用% 挂载点\nnone            3.8G  4.0K  3.8G    1% &#x2F;mnt&#x2F;wsl\ndrivers         458G  347G  112G   76% &#x2F;usr&#x2F;lib&#x2F;wsl&#x2F;drivers\nnone            3.8G     0  3.8G    0% &#x2F;usr&#x2F;lib&#x2F;wsl&#x2F;lib\n&#x2F;dev&#x2F;sdc       1007G  6.8G  949G    1% &#x2F;\nnone            3.8G   88K  3.8G    1% &#x2F;mnt&#x2F;wslg\nrootfs          3.8G  1.9M  3.8G    1% &#x2F;init\nnone            3.8G  4.0K  3.8G    1% &#x2F;run\nnone            3.8G     0  3.8G    0% &#x2F;run&#x2F;lock\nnone            3.8G     0  3.8G    0% &#x2F;run&#x2F;shm\nnone            3.8G     0  3.8G    0% &#x2F;run&#x2F;user\ntmpfs           3.8G     0  3.8G    0% &#x2F;sys&#x2F;fs&#x2F;cgroup\nnone            3.8G   88K  3.8G    1% &#x2F;mnt&#x2F;wslg&#x2F;versions.txt\nnone            3.8G   88K  3.8G    1% &#x2F;mnt&#x2F;wslg&#x2F;doc\ndrvfs           458G  347G  112G   76% &#x2F;mnt&#x2F;c\ndrvfs            18G   13G  5.4G   70% &#x2F;mnt&#x2F;d\ndrvfs           466G   24G  443G    5% &#x2F;mnt&#x2F;e\ndrvfs           466G   90G  377G   20% &#x2F;mnt&#x2F;f\n查看全部文件系统：\nhorik@Horik:~$ df -ah\n文件系统        容量  已用  可用 已用% 挂载点\nnone            3.8G  4.0K  3.8G    1% &#x2F;mnt&#x2F;wsl\ndrivers         458G  347G  112G   76% &#x2F;usr&#x2F;lib&#x2F;wsl&#x2F;drivers\nnone            3.8G     0  3.8G    0% &#x2F;usr&#x2F;lib&#x2F;wsl&#x2F;lib\n&#x2F;dev&#x2F;sdc       1007G  6.8G  949G    1% &#x2F;\nnone            3.8G   88K  3.8G    1% &#x2F;mnt&#x2F;wslg\n&#x2F;dev&#x2F;sdc       1007G  6.8G  949G    1% &#x2F;mnt&#x2F;wslg&#x2F;distro\nrootfs          3.8G  1.9M  3.8G    1% &#x2F;init\nnone            3.8G     0  3.8G    0% &#x2F;dev\nsysfs              0     0     0     - &#x2F;sys\nproc               0     0     0     - &#x2F;proc\ndevpts             0     0     0     - &#x2F;dev&#x2F;pts\nnone            3.8G  4.0K  3.8G    1% &#x2F;run\nnone            3.8G     0  3.8G    0% &#x2F;run&#x2F;lock\nnone            3.8G     0  3.8G    0% &#x2F;run&#x2F;shm\nnone            3.8G     0  3.8G    0% &#x2F;run&#x2F;user\nbinfmt_misc        0     0     0     - &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc\ntmpfs           3.8G     0  3.8G    0% &#x2F;sys&#x2F;fs&#x2F;cgroup\ncgroup2            0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;unified\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_prio\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;rdma\ncgroup             0     0     0     - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;misc\nnone            3.8G   88K  3.8G    1% &#x2F;mnt&#x2F;wslg&#x2F;versions.txt\nnone            3.8G   88K  3.8G    1% &#x2F;mnt&#x2F;wslg&#x2F;doc\nnone            3.8G   88K  3.8G    1% &#x2F;tmp&#x2F;.X11-unix\ndrvfs           458G  347G  112G   76% &#x2F;mnt&#x2F;c\ndrvfs            18G   13G  5.4G   70% &#x2F;mnt&#x2F;d\ndrvfs           466G   24G  443G    5% &#x2F;mnt&#x2F;e\ndrvfs           466G   90G  377G   20% &#x2F;mnt&#x2F;f\n显示 Compiler 目录中的可用空间量，如以下输出中所示：\nhorik@Horik:~$ df Compiler&#x2F; -h\n文件系统        容量  已用  可用 已用% 挂载点\n&#x2F;dev&#x2F;sdc       1007G  6.8G  949G    1% &#x2F;\ndu 显示目录的使用情况\ndu命令 也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。\n实例\n只显示总和的大小:\n# -s, --summarize                        仅显示总计，只列出最后加总的值。\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$  du -s .\n1239088 .\n显示总和的大小且易读:\n# -h, --human-readable                   以K，M，G为单位，提高信息的可读性。\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$ du -sh .\n1.2G    .\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$ du -sh FrontedTestStd&#x2F;\n655M    FrontedTestStd&#x2F;\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$ rm -rf FrontedTestStd&#x2F;\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$ du -sh .\n557M    .\n文件从大到小排序\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$ du -sh * |sort -rh\n655M    FrontedTestStd\n490M    FrontedTest\n2.0M    lib\n1.2M    img\n1.1M    src\n24K     lib.ll\n12K     out.ll\n4.0K    test.ll\n4.0K    Sysy.g4\n只显示当前目录下子目录的大小。\nhorik@Horik:~&#x2F;Compiler&#x2F;MegaSysy$ du -sh .&#x2F;*&#x2F;\n490M    .&#x2F;FrontedTest&#x2F;\n1.2M    .&#x2F;img&#x2F;\n2.0M    .&#x2F;lib&#x2F;\n1.1M    .&#x2F;src&#x2F;\n查看指定目录下文件所占的空间：\n# 此命令会递归查看指定目录的所有子目录\nhorik@Horik:~&#x2F;Compiler&#x2F;Toolchains$  du .&#x2F;*\n32      .&#x2F;clang\n28      .&#x2F;llvm\n\n进程管理命令\nps 报告当前系统的进程状态\nps命令 用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。\n# 语法\nps(选项)\n由于ps命令能够支持的系统类型相当的多，所以选项多的离谱！限于篇幅，这里就不一一列出了，下面还是写出一些常用实例。（摘自https://wangchujiang.com/linux-command/c/ps.html）\nps axo pid,comm,pcpu # 查看进程的PID、名称以及CPU 占用率\nps aux | sort -rnk 4 # 按内存资源的使用量对进程进行排序\nps aux | sort -nk 3  # 按 CPU 资源的使用量对进程进行排序\nps -A # 显示所有进程信息\nps -u root # 显示指定用户信息\nps -efL # 查看线程数\nps -e -o &quot;%C : %p :%z : %a&quot;|sort -k5 -nr # 查看进程并按内存使用大小排列\nps -ef # 显示所有进程信息，连同命令行\nps -ef | grep ssh # ps 与grep 常用组合用法，查找特定进程\nps -C nginx # 通过名字或命令搜索进程\nps aux --sort&#x3D;-pcpu,+pmem # CPU或者内存进行排序,-降序，+升序\nps -f --forest -C nginx # 用树的风格显示进程的层次关系\nps -o pid,uname,comm -C nginx # 显示一个父进程的子进程\nps -e -o pid,uname&#x3D;USERNAME,pcpu&#x3D;CPU_USAGE,pmem,comm # 重定义标签\nps -e -o pid,comm,etime # 显示进程运行的时间\nps -aux | grep named # 查看named进程详细信息\nps -o command -p 91730 | sed -n 2p # 通过进程id获取服务名称\n将目前属于您自己这次登入的 PID 与相关信息列示出来\nps -l\n#  UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD\n#  501   566   559     4006   0  31  0  4317620    228 -      Ss                  0 ttys001    0:00.05 &#x2F;App...cOS&#x2F;iTerm2 --server &#x2F;usr&#x2F;bin&#x2F;login -fpl kenny &#x2F;Ap...s&#x2F;MacOS&#x2F;iTerm2 --launch_shel\n#  501   592   577     4006   0  31  0  4297048     52 -      S                   0 ttys001    0:00.63 -zsh\n\nF 代表这个程序的旗标 (flag)， 4 代表使用者为 super user\nS 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍\nUID 程序被该 UID 所拥有\nPID 就是这个程序的 ID ！\nPPID 则是其上级父程序的ID\nC CPU 使用的资源百分比\nPRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍\nNI 这个是 Nice 值，在下一小节我们会持续介绍\nADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-”\nSZ 使用掉的内存大小\nWCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作\nTTY 登入者的终端机位置\nTIME 使用掉的 CPU 时间。\nCMD 所下达的指令为何\n\n\n在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID ，所以， 当前面使用 ps -l 的时候，只有三个 PID。\n\n列出目前所有的正在内存当中的程序\nps aux\n\n# USER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND\n# kenny             6155  21.3  1.7  7969944 284912   ??  S    二03下午 199:14.14 &#x2F;Appl...OS&#x2F;WeChat\n# kenny              559  20.4  0.8  4963740 138176   ??  S    二03下午  33:28.27 &#x2F;Appl...S&#x2F;iTerm2\n# _windowserver      187  18.0  0.6  7005748  95884   ??  Ss   二03下午 288:44.97 &#x2F;Syst...Light.WindowServer -daemon\n# kenny             1408  10.7  2.1  5838592 347348   ??  S    二03下午 138:51.63 &#x2F;Appl...nts&#x2F;MacOS&#x2F;Google Chrome\n# kenny              327   5.8  0.5  5771984  79452   ??  S    二03下午   2:51.58 &#x2F;Syst...pp&#x2F;Contents&#x2F;MacOS&#x2F;Finder\n\nUSER：该 process 属于那个使用者账号的\nPID ：该 process 的号码\n%CPU：该 process 使用掉的 CPU 资源百分比\n%MEM：该 process 所占用的物理内存百分比\nVSZ ：该 process 使用掉的虚拟内存量 (Kbytes)\nRSS ：该 process 占用的固定的内存量 (Kbytes)\nTTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。\nSTAT：该程序目前的状态，主要的状态有\n\nR ：该程序目前正在运作，或者是可被运作\nS ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。\nT ：该程序目前正在侦测或者是停止了\nZ ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态\n\n\nSTART：该 process 被触发启动的时间\nTIME ：该 process 实际使用 CPU 运作的时间\nCOMMAND：该程序的实际指令\n\n找出与 cron 与 syslog 这两个服务有关的 PID 号码\nps aux | egrep &#39;(cron|syslog)&#39;\n\n# root                50   0.0  0.0  4305532   1284   ??  Ss   二03下午   0:10.08 &#x2F;usr&#x2F;sbin&#x2F;syslogd\n# kenny            90167   0.0  0.0  4258468    184 s007  R+    9:23下午   0:00.00 egrep (cron|syslog)\n把所有进程显示出来，并输出到ps001.txt文件\nps -aux &gt; ps001.txt\n输出指定的字段\nps axo pid,comm,pcpu # 查看进程的PID、名称以及CPU 占用率\npstree\npstree命令 以树状图的方式展现进程之间的派生关系，显示效果比较直观。\n(base) [root@AliyunServer ~]# pstree\nsystemd─┬─AliSecGuard───6*[&#123;AliSecGuard&#125;]\n        ├─AliYunDun───23*[&#123;AliYunDun&#125;]\n        ├─AliYunDunUpdate───5*[&#123;AliYunDunUpdate&#125;]\n        ├─2*[agetty]\n        ├─aliyun-service───7*[&#123;aliyun-service&#125;]\n        ├─assist_daemon───7*[&#123;assist_daemon&#125;]\n        ├─atd\n        ├─auditd───&#123;auditd&#125;\n        ├─chronyd\n        ├─containerd───8*[&#123;containerd&#125;]\n        ├─containerd-shim─┬─java───54*[&#123;java&#125;]\n        │                 └─11*[&#123;containerd-shim&#125;]\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─dockerd─┬─2*[docker-proxy───4*[&#123;docker-proxy&#125;]]\n        │         └─8*[&#123;dockerd&#125;]\n        ├─lvmetad\n        ├─master─┬─pickup\n        │        └─qmgr\n        ├─nginx───nginx\n        ├─polkitd───6*[&#123;polkitd&#125;]\n        ├─python3───python3───2*[&#123;python3&#125;]\n        ├─redis-server───4*[&#123;redis-server&#125;]\n        ├─rsyslogd───2*[&#123;rsyslogd&#125;]\n        ├─3*[sh───node─┬─node───10*[&#123;node&#125;]]\n        │              └─10*[&#123;node&#125;]]\n        ├─sshd───sshd───bash───pstree\n        ├─systemd-journal\n        ├─systemd-logind\n        └─systemd-udevd\n显示当前所有进程的进程号和进程id\npstree -p\n显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示。\npstree  -a\n获取 SSH 会话的 PID\npstree -p | grep ssh\n\n#  |-sshd(1221)-+-sshd(2768)---bash(2770)-+-grep(2810)\n#  |            &#96;-sshd(2807)---sshd(2808)\n启动进程\n手工启动\n前台启动：直接输入命名启动程序\nsource .&#x2F;startDjango.sh\n后台启动：在命令后输入&amp;操作符\nsource .&#x2F;startDjango.sh &amp;\n调度启动\nat 在指定时间执行一个任务\n\n\n在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程。\n\n\n可通过命令ps -ef | grep atd 搜索进程atd是否正在运行。\n\n\n如果没有运行，可通过命令/etc/init.d/atd start or /etc/init.d/atd restart启动atd进程\n\n\nat命令 用于在指定时间执行命令。at允许使用一套相当复杂的指定时间的方法。它能够接受在当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。\n上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units，now就是当前时间，time-units是时间单位，这里能够是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。\n三天后的下午 5 点锺执行/bin/ls：\n[root@localhost ~]# at 5pm+3 days\nat&gt; &#x2F;bin&#x2F;ls\nat&gt; &lt;EOT&gt;\t# EOT是文本结束符 按ctrl+D就可以\njob 7 at 2013-01-08 17:00\n明天17点钟，输出时间到指定文件内：\n[root@localhost ~]# at 17:20 tomorrow\nat&gt; date &gt;&#x2F;root&#x2F;2013.log\nat&gt; &lt;EOT&gt;\njob 8 at 2013-01-06 17:20\n计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务：\n    [root@localhost ~]# atq\n8       2013-01-06 17:20 a root\n7       2013-01-08 17:00 a root\n删除已经设置的任务：\n[root@localhost ~]# atq\n8       2013-01-06 17:20 a root\n7       2013-01-08 17:00 a root\n\n[root@localhost ~]# atrm 7\n[root@localhost ~]# atq\n8       2013-01-06 17:20 a root\n显示已经设置的任务内容：\n[root@localhost ~]# at -c 8\n#!&#x2F;bin&#x2F;sh\n# atrun uid&#x3D;0 gid&#x3D;0\n# mail     root 0\numask 22此处省略n个字符\ndate &gt;&#x2F;root&#x2F;2013.log\ncrontab 提交和管理用户的需要周期性执行的任务\n详情参见https://wangchujiang.com/linux-command/c/crontab.html\ncrontab命令 被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。\n它通过/etc/crontab配置文件或者crontab命令实现，这里介绍配置文件编辑方式\n/etc/crontab文件包括下面几行：\nSHELL&#x3D;&#x2F;bin&#x2F;bash\nPATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin\nMAILTO&#x3D;&quot;&quot;HOME&#x3D;&#x2F;\n\n# run-parts\n51 * * * * root run-parts &#x2F;etc&#x2F;cron.hourly\n24 7 * * * root run-parts &#x2F;etc&#x2F;cron.daily\n22 4 * * 0 root run-parts &#x2F;etc&#x2F;cron.weekly\n42 4 1 * * root run-parts &#x2F;etc&#x2F;cron.monthly\ncrontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：\nminute   hour   day   month   week   command     顺序：分 时 日 月 周\ncrond服务\n&#x2F;sbin&#x2F;service crond start    # 启动服务\n&#x2F;sbin&#x2F;service crond stop     # 关闭服务\n&#x2F;sbin&#x2F;service crond restart  # 重启服务\n&#x2F;sbin&#x2F;service crond reload   # 重新载入配置\n查看crontab服务状态：\nservice crond status\n手动启动crontab服务：\nservice crond start\n查看crontab服务是否已设置为开机启动，执行命令：\nntsysv\n加入开机自动启动：\nchkconfig –level 35 crond on\n改变进程的运行方式\njobs 显示作业的状态\n\n语法 jobs (args)\n\n-l\t在作业信息中额外的列出PID。\n-n\t只列出最近一次通知以来状态变更的作业。\n-p\t只列出PID。\n-r\t只输出处于运行状态的作业。\n-s\t只输出处于停止状态的作业。\n[user2@pc] ssh 192.168.1.4\npc@192.168.1.4&#39;s password:\n# 此时按下ctrl+z使得交互停止。\n[1]+  Stopped                 ssh 192.168.1.4\n\n[user2@pc] sleep 60 &amp;\n[2] 13338\n\n[user2@pc] jobs\n[1]-  Stopped                 ssh 192.168.1.4\n[2]   Running                 sleep 60 &amp;\n\n[user2@pc] jobs -l\n[1]- 12927 Stopped                 ssh 192.168.1.4\n[2]  13338 Running                 sleep 60 &amp;\n\n[user2@pc] jobs -p\n12927\n13338\n\n[user2@pc] jobs -s\n[1]-  Stopped                 ssh 192.168.1.4\n\n[user2@pc] jobs -r\n[2]   Running                 sleep 60 &amp;\n\n[user2@pc] kill -9 12927\n[2]   Done                    sleep 60\n\n[user2@pc] jobs -n -l\n[1]+ 12927 Killed             ssh 192.168.1.4\n\n[user2@pc] jobs -n -l\nbg 把命令程序调到后台\n\n用于将作业放到后台运行，使前台可以执行其他任务。该命令的运行效果与在指令后面添加符号&amp;的效果是相同的，都是将其放到系统后台执行。\n若前台任务中只有一个，则使用该命令时可以省略任务号。\n该命令需要set选项monitor处于开启状态时才能执行；查看作业控制状态：输入set -o查看monitor行；执行set -o monitor或set -m开启该选项。\n语法：bg [job_spec ...]\n\n# 运行sleep命令，然后按下ctrl+z。\nsleep 60\n^Z\n[1]+  Stopped                 sleep 60\n\n# 使用bg命令使得作业在后台运行。\nbg %1\n\n# 返回信息：\n[1]+ sleep 60 &amp;\nfg 把后台命令调回前台来\n\n用于将后台作业（在后台运行的或者在后台挂起的作业）放到前台终端运行。\n若后台任务中只有一个，则使用该命令时可以省略任务号。\n该命令需要set选项monitor处于开启状态时才能执行；查看作业控制状态：输入set -o查看monitor行；执行set -o monitor或set -m开启该选项。\n语法 fg [job_spec ...]\n\n# 运行sleep命令，然后按下ctrl+z。\nsleep 60\n^Z\n[1]+  Stopped                 sleep 60\n\n# 使用fg命令使得作业在前台运行。\nfg %1\n\n# 返回信息：\nsleep 60\nkill 发送信号到进程\n# -l        列出信号名称。如果在该选项后提供了数字那么假设它是信号名称对应的数字。\n[user2@pc] kill -l 9\nKILL\n\n# 列出所有信号名称：\n[user2@pc] kill -l\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n63) SIGRTMAX-1  64) SIGRTMAX\n\n# 下面是常用的信号。\n# 只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。\n\nHUP     1    终端挂断\nINT     2    中断（同 Ctrl + C）\nQUIT    3    退出（同 Ctrl + \\）\nKILL    9    强制终止\nTERM   15    终止\nCONT   18    继续（与STOP相反，fg&#x2F;bg命令）\nSTOP   19    暂停（同 Ctrl + Z）\n实例\n# 以下发送KILL信号的形式等价。当然还有更多的等价形式，在此不一一列举了。\n[user2@pc] kill -s SIGKILL PID\n[user2@pc] kill -s KILL PID\n[user2@pc] kill -n 9 PID\n[user2@pc] kill -9 PID\n\n[user2@pc] sleep 90 &amp;\n[1] 178420\n\n# 终止作业标识符为1的作业。\n[user2@pc] kill -9 %1\n\n[user2@pc] jobs -l\n[1]+ 178420 KILLED                  ssh 192.168.1.4\n\n[user2@pc] sleep 90 &amp;\n[1] 181357\n\n# 发送停止信号。\n[user2@pc] kill -s STOP 181357\n\n[user2@pc] jobs -l\n[1]+ 181537 Stopped (signal)        sleep 90\n\n# 发送继续信号。\n[user2@pc] kill -s CONT 181357\n\n[user2@pc] jobs -l\n[1]+ 181537 Running                 sleep 90 &amp;\n\n输入输出重定向\n标准输入/输出\n每个Linux进程都会打开3个文件用来处理程序的输入输出工作\n\n\n文件\n文件描述符\n默认设备\n\n\n\n\n输入文件：标准输入\n0\n键盘\n\n\n输出文件：标准输出\n1\n屏幕\n\n\n错误输出文件：标准错误输出\n2\n屏幕\n\n\n重定向\n\n\n&lt; 输入重定向\n语法： 命令 &lt; 输入文件**\n示例： cat &lt; inputfile\n\n\n&gt; 输出重定向\n语法： 命令 &gt; 输出文件**\n示例： ls &gt; outputfile\n\n\n2&gt; 错误输出重定向\n语法： 命令 2&gt;errorfile\n示例：ls 2 &gt; inputfile\n\n\n常用文件重定向命令\n\n\n重定向命令\n意义\n\n\n\n\ncommand &gt; filename\n把标准输出重定向到一个文件中\n\n\ncommand &gt;&gt; filename\n把标准输出追加重定向到一个文件中\n\n\ncommand 1&gt; fielname\n把标准输出重定向到一个文件中\n\n\ncommand &gt; filename 2 &gt; &amp;1\n把标准输出和标准错误输出重定向到一个文件中\n\n\ncommand 2 &gt; filename\n把标准错误输出重定向到一个文件中\n\n\ncommand &lt; filename &gt; filename2\n以filename为标准输入，filename2为标准输出\n\n\ncommand &lt; filename\n把filename作为命令的标准输入\n\n\ncommand &lt;&lt; delimiter\n从标准输入读入数据，直到遇到delimiter为止\n\n\n\n\nReference\n[1] 北京航空航天大学软件学院系统编程课程第一章PPT–01 Linux基础\n[2] Linux编程基础 李养群等著\n[3] Linux命令搜索引擎\n\n","thumbnail":"https://oss.horik.cn/PicGo/header-linux-basicskill.jpg","plink":"http://blog.horik.cn/2022/09/04/「系统编程」常用Linux命令/"},{"title":"404","date":"2022-09-05T10:08:38.000Z","date_formatted":{"ll":"Sep 5, 2022","L":"09/05/2022","MM-DD":"09-05"},"updated":"2022-09-07T20:50:48.369Z","content":"","plink":"http://blog.horik.cn/404/"}]