{"title":"「编译原理」语法分析--进阶内容","date":"2022-11-03T09:59:01.000Z","date_formatted":{"ll":"Nov 3, 2022","L":"11/03/2022","MM-DD":"11-03"},"link":"2022/11/03/「编译原理」语法分析-进阶内容","comments":true,"updated":"2022-11-07T01:55:52.491Z","content":"<p>语法分析的基本功能是根据文法规则，从源程序单词符号串中识别出语法成分，并进行语法检查。换言之语法分析的任务就是识别符号串S是否为某语法成分。</p>\n<p>语法分析有两大类分析方法：</p>\n<ul>\n<li>\n<p>自顶向下分析（推导过程）【需要解决左递归问题和回溯问题】</p>\n<ul>\n<li>递归子程序法</li>\n<li>LL分析法</li>\n</ul>\n</li>\n<li>\n<p>自底向上分析（规约过程）【需要解决句柄的识别问题】</p>\n<ul>\n<li>算符优先分析法</li>\n<li>LR分析法</li>\n</ul>\n</li>\n</ul>\n<p>下面分别介绍这四种算法的分析过程。</p>\n<h2 id=\"自顶向下分析\">自顶向下分析<a title=\"#自顶向下分析\" href=\"#自顶向下分析\"></a></h2>\n<p>给定符号串S，若预测是某一语法成分，则可根据该语法成分的文法,设法为S构造一棵语法树， 若成功,则S最终被识别为某一语法成分,即 S属于L(G[Z])，其中G[Z]为某语法成分的文法，若不成功, 则S不属于L(G[Z])。</p>\n<h3 id=\"消除左递归\">消除左递归<a title=\"#消除左递归\" href=\"#消除左递归\"></a></h3>\n<h3 id=\"解决回溯\">解决回溯<a title=\"#解决回溯\" href=\"#解决回溯\"></a></h3>\n<h4 id=\"计算first集合\">计算First集合<a title=\"#计算first集合\" href=\"#计算first集合\"></a></h4>\n<h4 id=\"假读\">假读<a title=\"#假读\" href=\"#假读\"></a></h4>\n<h3 id=\"递归子程序法\">递归子程序法<a title=\"#递归子程序法\" href=\"#递归子程序法\"></a></h3>\n<h4 id=\"消除左递归-1\">消除左递归<a title=\"#消除左递归-1\" href=\"#消除左递归-1\"></a></h4>\n<h3 id=\"ll分析法\">LL分析法<a title=\"#ll分析法\" href=\"#ll分析法\"></a></h3>\n<img src=\"/2022/11/03/%E3%80%8C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8D%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/image-20221103100128418.png\" alt=\"image-20221103100128418\" style=\"zoom:67%;\">\n<p>当文法中某一非终结符呈现在栈顶时,根据当前的输入符号,分析表应指示要用该非终结符的哪 一条规则去匹配输入串(即进行一步最左推导)</p>\n<h2 id=\"自底向上分析\">自底向上分析<a title=\"#自底向上分析\" href=\"#自底向上分析\"></a></h2>\n<h3 id=\"算法优先分析法\">算法优先分析法<a title=\"#算法优先分析法\" href=\"#算法优先分析法\"></a></h3>\n<h3 id=\"lr分析法\">LR分析法<a title=\"#lr分析法\" href=\"#lr分析法\"></a></h3>\n<h2 id><a title=\"#\" href=\"#\"></a></h2>\n<img src=\"/2022/11/03/%E3%80%8C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8D%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/image-20221103100353700.png\" alt=\"image-20221103100353700\" style=\"zoom:67%;\">\n<blockquote>\n<p>FIRST集、FOLLOW集的构造方法</p>\n<ul>\n<li>作为写题而言，FIRST集直接肉眼看就行</li>\n</ul>\n<img src=\"/2022/11/03/%E3%80%8C%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8D%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/image-20221103100430598.png\" alt=\"image-20221103100430598\" style=\"zoom:67%;\">\n</blockquote>\n","prev":{"title":"「拥塞控制算法」PCC Vivace阅读笔记","link":"2022/11/07/「拥塞控制算法」PCC-Vivace阅读笔记"},"next":{"title":"「编译原理」正则表达式&有限自动机理论","link":"2022/10/25/compiler-Regular-expressions-and-finite-automata-theory"},"plink":"http://blog.horik.cn/2022/11/03/「编译原理」语法分析-进阶内容/","toc":[{"id":"自顶向下分析","title":"自顶向下分析","index":"1","children":[{"id":"消除左递归","title":"消除左递归","index":"1.1"},{"id":"解决回溯","title":"解决回溯","index":"1.2","children":[{"id":"计算first集合","title":"计算First集合","index":"1.2.1"},{"id":"假读","title":"假读","index":"1.2.2"}]},{"id":"递归子程序法","title":"递归子程序法","index":"1.3","children":[{"id":"消除左递归-1","title":"消除左递归","index":"1.3.1"}]},{"id":"ll分析法","title":"LL分析法","index":"1.4"}]},{"id":"自底向上分析","title":"自底向上分析","index":"2","children":[{"id":"算法优先分析法","title":"算法优先分析法","index":"2.1"},{"id":"lr分析法","title":"LR分析法","index":"2.2"}]},{"id":"","title":"","index":"3"}],"reward":true,"copyright":{"author":"Horik","link":"<a href=\"http://blog.horik.cn/2022/11/03/「编译原理」语法分析-进阶内容/\" title=\"「编译原理」语法分析--进阶内容\">http://blog.horik.cn/2022/11/03/「编译原理」语法分析-进阶内容/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"November 3, 2022","updated":"November 7, 2022"},"reading_time":"535 words in 4 min"}