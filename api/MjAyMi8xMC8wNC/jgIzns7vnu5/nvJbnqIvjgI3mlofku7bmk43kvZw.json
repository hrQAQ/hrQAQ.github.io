{"title":"「系统编程」文件操作","date":"2022-10-04T20:10:06.000Z","date_formatted":{"ll":"Oct 4, 2022","L":"10/04/2022","MM-DD":"10-04"},"thumbnail":"https://images.unsplash.com/photo-1519052537078-e6302a4968d4?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","link":"2022/10/04/「系统编程」文件操作","comments":true,"tags":["Linux基础","系统调用"],"categories":["系统编程"],"updated":"2022-10-05T22:14:40.976Z","content":"<blockquote>\n<p>又在写完后才找到API文档…<br>\n本文涉及的 api 可以参考 <a href=\"https://wizardforcel.gitbooks.io/linux-c-api-ref/content/\" target=\"_blank\">Linux C API参考手册</a></p>\n</blockquote>\n<hr>\n<h2 id=\"文件的类型\">文件的类型<a title=\"#文件的类型\" href=\"#文件的类型\"></a></h2>\n<p><a href=\"https://haicoder.net/linux/linux-filetype.html\" target=\"_blank\">Linux七种文件类型详解</a></p>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>文件属性</th>\n<th>文件类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>常规文件，即 file</td>\n</tr>\n<tr>\n<td>d</td>\n<td>目录文件</td>\n</tr>\n<tr>\n<td>b</td>\n<td>block device 即块设备文件，如硬盘;支持以 block 为单位进行随机访问</td>\n</tr>\n<tr>\n<td>c</td>\n<td>character device 即字符设备文件，如键盘支持以 character 为单位进行线性访问</td>\n</tr>\n<tr>\n<td>l</td>\n<td>symbolic link 即符号链接文件，又称软链接文件</td>\n</tr>\n<tr>\n<td>p</td>\n<td>pipe 即命名管道文件</td>\n</tr>\n<tr>\n<td>s</td>\n<td>socket 即套接字文件，用于实现两个进程进行通信</td>\n</tr>\n</tbody>\n</table></div></div><h2 id=\"文件的权限\">文件的权限<a title=\"#文件的权限\" href=\"#文件的权限\"></a></h2>\n<p>umask指定了在建立文件时预设的权限掩码。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">umask\n&gt;&gt; 0022\n\numask -S\n&gt;&gt; u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"文件读写操作syscall\">文件读写操作Syscall<a title=\"#文件读写操作syscall\" href=\"#文件读写操作syscall\"></a></h2>\n<p>一个比较详细的介绍在<a href=\"https://www.cnblogs.com/tongye/p/9830006.html\" target=\"_blank\">这里</a>，本文只记录API</p>\n<ul>\n<li>\n<p>打开 open</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para pathname：要创建的文件名（包括路径信息）\n* @para\tflags：打开的模式\n* @return 成功返回文件描述符 否则返回-1\n*&#x2F;\nint open(const char* pathname, int flags, ...);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th>Mode</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O_RDONLY</td>\n<td>只读</td>\n</tr>\n<tr>\n<td>O_WRONLY</td>\n<td>只写</td>\n</tr>\n<tr>\n<td>O_RDWR</td>\n<td>读写</td>\n</tr>\n<tr>\n<td>O_NONBLOCK</td>\n<td>非阻塞I/O，如果read(2)调用没有可读取的数据，或者如果write(2)操作将阻塞，则read或write调用将返回-1和EAGAIN错误</td>\n</tr>\n<tr>\n<td>O_APPEND</td>\n<td>每次写的数据都添加到文件尾</td>\n</tr>\n<tr>\n<td>O_TRUNC</td>\n<td>若此文件存在，并以读写或只写打开，则文件长度为0</td>\n</tr>\n<tr>\n<td>O_CREAT</td>\n<td>若文件不存在，则创建该文件。此时，open 函数需要第三个参数，用于指定该文件的访问权限位</td>\n</tr>\n<tr>\n<td>O_EXCL</td>\n<td>若同时指定了O_CREAT标志，而文件已经存在，则会出错。可用于测试文件是否存在</td>\n</tr>\n<tr>\n<td>O_DIRECT</td>\n<td>最小化或去掉reading和writing的缓存影响。系统将企图避免缓存你的读或写的数 据。如果不能够避免缓存，那么它将最小化已经被缓存了的数据造成的影响。如果<br>这个标志用的不够好，将大大的降低性能</td>\n</tr>\n<tr>\n<td>O_ASYNC</td>\n<td>当I/O可用的时候，允许SIGIO信号发送到进程组，例如：当有数据可以读的时候</td>\n</tr>\n</tbody>\n</table></div></div></li>\n<li>\n<p>创建 creat</p>\n<p>注意：当文件存在时，调用creat函数，会将文件的大小变为0</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para pathname：要创建的文件名（包括路径信息）\n* @para\tmode：同open的第三个参数，讨论文件的访问权限位\n* @return 成功返回只写打开的文件描述符\n*\t\t  出错返回-1\n*&#x2F;\nint creat(const char *pathname, mode_t mode);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>替换creat的方式</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int open(pathname, O_RDWR | O_CREAT | O_TRUNC,mode);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>定位 lseek</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para filedes: open&#x2F;creat函数返回的文件描述符\n* @para offset: 相对偏移量,需结合whence才能计算出真正的偏移量\n* @para: Whence: 从何处开始计算偏移量\n*\t\t\t   \t SEEK_SET \t文件开始处\\\n* \t\t\t\t SEEK_CUR \t文件当前偏移量\\\n*\t\t\t\t SEEK_END\t文件尾部\\\n* @return: 类型off_t：通常情况下是32位数据类型 \\\n*\t\t\t若成功，返回新的文件偏移量 \n*\t\t\t若出错，返回-1\n*&#x2F;\noff_t lseek(int filedes, off_t offset, int whence)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>读 read</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para fd: 文件描述符\n* @para buff: 指向缓冲区，用于存放从文件读出的数据\n* @para nbytes: 需要从文件中读出的字节数\n* @constraint: 缓冲区的大小&gt;&#x3D;nbytes\n* @return: 成功，返回从文件中实际读到的字节数 当读到文件结尾时，则返回0\n*          出错，返回-1\n*&#x2F;\nsize_t read(int fd, void *buff, size_t nbytes)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>写 write</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para fd: 文件描述符\n* @para buff: 指向缓冲区，存放了需要写入文件的数据\n* @para nbytes: 需要写入文件的字节数\n* @return: 成功，返回实际写入文件的字节数\n*          出错，返回-1\n*&#x2F;\nsize_t write(int fd, const void *buff, size_t nbytes);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>关闭 close</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include&lt;fcntl.h&gt;\n\n&#x2F;**\n* @para fd: 文件描述符\n* @return: 成功，返回0\n*          出错，返回-1\n*&#x2F;\nint close(int filedes);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>\n<p>删除 unlink</p>\n  <pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;unistd.h&gt; \n\n&#x2F;**\n* @para path: 要删除文件的路径\n* @return: 成功，返回0\n*          出错，返回-1\n*&#x2F;\nint unlink(char* path);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<h2 id=\"文件描述符的属性控制\">文件描述符的属性控制<a title=\"#文件描述符的属性控制\" href=\"#文件描述符的属性控制\"></a></h2>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys&#x2F;types.h&gt;\n\nint result&#x3D;fcntl(int fd,int cmd);\nint result&#x3D;fcntl(int fd,int cmd,long arg,...);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:left\">cmd</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">F_DUPFD</td>\n<td style=\"text-align:left\">复制文件描述符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_GETFD</td>\n<td style=\"text-align:left\">获得文件描述符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_SETFD</td>\n<td style=\"text-align:left\">设置文件描述符</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_GETFL</td>\n<td style=\"text-align:left\">获取文件描述符当前模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_SETFL</td>\n<td style=\"text-align:left\">设置文件描述符当前模式</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_GETOWN</td>\n<td style=\"text-align:left\">获得异步I/O所有权</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_SETOWN</td>\n<td style=\"text-align:left\">设置异步I/O所有权</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_GETLK</td>\n<td style=\"text-align:left\">获得记录锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_SETLK</td>\n<td style=\"text-align:left\">设置记录锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">F_SETLKW</td>\n<td style=\"text-align:left\">设置记录锁</td>\n</tr>\n</tbody>\n</table></div></div><p><strong>常见用法</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;增加文件的某个flags，比如文件是阻塞的，想设置成非阻塞:\nflags &#x3D; fcntl(fd,F_GETFL,0); \t&#x2F;&#x2F;首先获取文件描述符属性\nflags |&#x3D; O_NONBLOCK; \t\t\t&#x2F;&#x2F;修改文件描述符属性，设置为非阻塞模式\nfcntl(fd,F_SETFL,flags);\t\t&#x2F;&#x2F;设置文件描述符属性\n\n&#x2F;&#x2F;取消文件的某个flags，比如文件是追加模式的， 想设置成为非追加模式:\nflags &#x3D; fcntl(fd,F_GETFL,0);\nflags &amp;&#x3D; ~O_APPEND; &#x2F;&#x2F;对追加模式取非表示取消追加模式。\nfcntl(fd,F_SETFL,flags);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"文件\\目录相关syscall\">文件\\目录相关Syscall<a title=\"#文件\\目录相关syscall\" href=\"#文件\\目录相关syscall\"></a></h2>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;sys&#x2F;types.&gt;\n#include &lt;dirent.h&gt;\n\n&#x2F;**\n* 打开目录，返回一个指向DIR的指针，从而创建一个到目录的连接\n*&#x2F;\nDIR *opendir(const char *dir_name); \n\n&#x2F;**\n* 每次从DIR中读取目录项信息，该目录信息保存在结构体dirent中 \n*&#x2F;\nstruct dirent&#123;\n    char d_name[1];\t&#x2F;* 文件名称 *&#x2F;\n\tint d_fileno; \t&#x2F;*文件的inode号*&#x2F;\n&#125;;\nstruct dirent * readdir(DIR *dir); \n\n&#x2F;**\n* 目录的定位\n*&#x2F;\nvoid seekdir(DIR *dir, off_t offset);\noff_t telldir(DIR *dir);\nvoid rewinddir(DIR *dir);\n\n&#x2F;**\n* 目录的创建&#x2F;删除&#x2F;改变&#x2F;获得\n*&#x2F;\nint res&#x3D;mkdir(char*pathname,mode_t mode);\nint res&#x3D;rmdir(char*pathname);\nint res&#x3D;chdir(const char* path);\nchar *getcwd(char *buf, size_t size);\n\n&#x2F;**\n* 目录或者文件重命名,同时可以改变位置\n* 本质只是将链接移动到另外一个目录\n*&#x2F;\nint res&#x3D;rename(const char*from,const char *to);\n&#x2F;&#x2F; eg\nrename(&quot;y&quot;,&quot;c&#x2F;d2&#x2F;y.old&quot;);\n\n&#x2F;**\n* 文件与目录的属性\n*&#x2F;\n#include &lt;sys&#x2F;stat.h&gt; \nint result&#x3D;stat(char *fname,struct stat *bufp);\nint lstat(const char *restrict path, struct stat *restrict buf);\nint fstat(int fildes, struct stat *buf);\n\nstruct stat &#123; \n    dev_t st_dev;\t&#x2F;*包含该文件的设备ID号*&#x2F; \n    ino_t st_ino;\t&#x2F;*文件的inode file serial number*&#x2F;\n\tmode_t st_mode;\t\t&#x2F;*文件类型及权限模式*&#x2F; \n    nlink_t st_nlink;\t&#x2F;*该文件的链接数*&#x2F;\n\tuid_t st_uid;\t&#x2F;*文件所有者的用户ID*&#x2F;\n\tgid_t st_uid;\t&#x2F;*文件的组ID*&#x2F;\n\tdev_t st_rdev;\t&#x2F;*如果文件为字符或者块设备时的设备ID*&#x2F; \n    off_t st_size;\t&#x2F;*若文件为普通文件，文件的字节数*&#x2F;\n\ttime_t st_atime; &#x2F;*最近的访问时间*&#x2F; \n    time_t st_mtime; &#x2F;*最近数据修改时间*&#x2F; \n    time_t st_ctime; &#x2F;*最近文件状态改变的时间*&#x2F;\n&#125;\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"链接\">链接<a title=\"#链接\" href=\"#链接\"></a></h2>\n<p>目录文件中存储的是文件名称及所对应的 inode，它被称为链接。不同的文件名可以对应同一个inode，链接数是指向该inode的文件数。</p>\n<p>链接分为硬链接和符号链接，<a href=\"https://www.jianshu.com/p/dde6a01c4094\" target=\"_blank\">这篇文</a>有具体介绍它们的区别。评论区有一句话总结的挺好：文件名本身是指针，硬链接是和文件名同一级别的指针，软链接(符号链接)是指向指针的指针。</p>\n<p>下面是使用方法</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 硬链接\nln testfile hard_link\n# 软连接(符号链接)\nln -s testfile softlink<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"文件io和标准io的区别\">文件IO和标准IO的区别<a title=\"#文件io和标准io的区别\" href=\"#文件io和标准io的区别\"></a></h2>\n<p><a href=\"https://www.cnblogs.com/vamei/archive/2012/09/19/2692452.html?spm=a2c6h.12873639.article-detail.5.d1c47d42vlNjAr\" target=\"_blank\">详见此文</a></p>\n<ol>\n<li>\n<p>文件I/O 又称为低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。</p>\n<ul>\n<li>\n<p>通过<strong>文件I/O</strong>读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销</p>\n</li>\n<li>\n<p>文件I/O中用文件描述符表现一个打开的文件，可以访问不同类型的文件如普通文件、设备文件和管道文件等。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>标准I/O被称为高级磁盘I/O，遵循ANSI C相关标准。只要开发环境中有标准I/O库，标准I/O就可以使用。</p>\n<ul>\n<li>\n<p>标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。</p>\n</li>\n<li>\n<p>标准I/O中用FILE（流）表示一个打开的文件，通常只用来访问普通文件。</p>\n</li>\n</ul>\n</li>\n</ol>\n","prev":{"title":"「编译原理」数据流分析算法","link":"2022/10/17/「编译原理」数据流分析算法"},"next":{"title":"「系统编程」Shell编程FAQ","link":"2022/09/27/「系统编程」Shell编程FAQ"},"plink":"http://blog.horik.cn/2022/10/04/「系统编程」文件操作/","toc":[{"id":"文件的类型","title":"文件的类型","index":"1"},{"id":"文件的权限","title":"文件的权限","index":"2"},{"id":"文件读写操作syscall","title":"文件读写操作Syscall","index":"3"},{"id":"文件描述符的属性控制","title":"文件描述符的属性控制","index":"4"},{"id":"文件\\目录相关syscall","title":"文件\\目录相关Syscall","index":"5"},{"id":"链接","title":"链接","index":"6"},{"id":"文件io和标准io的区别","title":"文件IO和标准IO的区别","index":"7"}],"reward":true,"copyright":{"author":"Horik","link":"<a href=\"http://blog.horik.cn/2022/10/04/「系统编程」文件操作/\" title=\"「系统编程」文件操作\">http://blog.horik.cn/2022/10/04/「系统编程」文件操作/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"October 4, 2022","updated":"October 5, 2022"},"reading_time":"2034 words in 14 min"}